<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>反射机制原理及使用</title>
      <link href="/2019/03/15/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/03/15/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>最近在研究蓝牙源码时发现，有部分类是被 @hide 掉的，例如 通过蓝牙获取通讯录及通话记录，是通过蓝牙 Pbap 协议，具体实现是在 BluetoothPbapClient 中实现，而该类是 hide 的，注释为当前未完成，后期变动可能会比较大，所以hide掉不会放在 sdk 里使用。<br>这种情况下，一般是通过修改源码重新编译来实现该需求，不过我为了快速完成需求，考虑使用反射来调用 BluetoothPbapClient 中的接口。<br>在此记录下反射的使用及原理。</p><p>反射，是能够在程序运行时修改程序的行为。</p><a id="more"></a><h1 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h1><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="获取-Class"><a href="#获取-Class" class="headerlink" title="获取 Class"></a>获取 Class</h3><p>Class 就是一个对象，它用来代表运行在 Java 虚拟机中的类和接口。</p><p>获取三种的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student.getClass();</span><br><span class="line"></span><br><span class="line">Student.class;</span><br><span class="line"></span><br><span class="line">Class.forName(<span class="string">"com.xx.Student"</span>);</span><br></pre></td></tr></table></figure><h3 id="获取-Class-修饰符"><a href="#获取-Class-修饰符" class="headerlink" title="获取 Class 修饰符"></a>获取 Class 修饰符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><h3 id="获取-Filed"><a href="#获取-Filed" class="headerlink" title="获取 Filed"></a>获取 Filed</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类所有的成员变量，包括私有或者非私有的，不包括从祖先类继承的非私有成员变量</span></span><br><span class="line">getDeclaredFields();</span><br><span class="line">getDeclaredField(String name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有当前类及从祖先类继承的非私有成员变量</span></span><br><span class="line">getFields();</span><br><span class="line">getField(String name);</span><br></pre></td></tr></table></figure><h3 id="获取-Method"><a href="#获取-Method" class="headerlink" title="获取 Method"></a>获取 Method</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredMethods()</span><br><span class="line">getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">getMethods()</span><br><span class="line">getMethod(String name, Class&lt;?&gt;... parameterTypes)</span><br></pre></td></tr></table></figure><h3 id="获取-Constructor"><a href="#获取-Constructor" class="headerlink" title="获取 Constructor"></a>获取 Constructor</h3><p>注：Constructor 不能从父类继承，所以就没有办法通过 getConstructor() 获取到父类的 Constructor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredConstructors()</span><br><span class="line">getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line"></span><br><span class="line">getConstructors()</span><br><span class="line">getConstructor(Class&lt;?&gt;... parameterTypes)</span><br></pre></td></tr></table></figure><h3 id="获取-Field-的类型"><a href="#获取-Field-的类型" class="headerlink" title="获取 Field 的类型"></a>获取 Field 的类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法可以获取到泛型类型</span></span><br><span class="line">getGenericType()</span><br><span class="line"></span><br><span class="line">getType()</span><br></pre></td></tr></table></figure><h3 id="获取Field-修饰符"><a href="#获取Field-修饰符" class="headerlink" title="获取Field 修饰符"></a>获取Field 修饰符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getModifiers()</span><br></pre></td></tr></table></figure><h1 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h1><p>java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI（Run-Time Type Identification），它假定我们在编译时已经知道了所有的类型信息，另一种是反射机制。</p><p>它允许我们在运行时发现和使用类的信息，也就是这里要说的，通过 Class 类与 reflect 类库一起对反射进行支持，该类库包括 Field、Method 和 Constructor 类。这些类的对象由JVM在启动时创建，用以表示未知类里对应的成员。这样可以使用 Contructor 创建新的对象，用 get() 和 set() 方法获取、修改类中成员等，用 invoke() 调用 Method 对象关联的方法等等。</p><p>这样对象信息可以在运行时完全确定下来，而在编译时不需要知道任何关于类的信息。</p><p>反射机制并没有很神奇之处，当通过反射对一个未知类型的对象做处理时，JVM只是简单的检查这个对象属于哪个特定的类，因此那个类的 .class 对于JVM是肯定可以获取的。</p><p>综上，对于 RTTI 和 反射的区别只在于：</p><ul><li>RTTI 是编译器在编译时打开和检查 .class 文件</li><li>反射 是在运行时打开和检查 .class 文件</li></ul>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reflection </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CarRadioService 分析</title>
      <link href="/2019/03/04/aosp-CarRadioService-%E5%88%86%E6%9E%90/"/>
      <url>/2019/03/04/aosp-CarRadioService-%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="CarRadioService-分析"><a href="#CarRadioService-分析" class="headerlink" title="CarRadioService 分析"></a>CarRadioService 分析</h1><p>需求需要自己做个车机版 Radio app，需要 framework 提供接口，并且需要定义在 CarService 中，所以这里对 CarService 的流程做了个简单地总结，以及如何在 framework 层定义接口，最后是在模拟器中如何调试接口。</p><a id="more"></a><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>步骤 0-27：</p><p>CarService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mVehicle = getVehicle(<span class="keyword">null</span> <span class="comment">/* Any Vehicle HAL interface name */</span>);</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    mICarImpl = <span class="keyword">new</span> ICarImpl(<span class="keyword">this</span>, mVehicle, SystemInterface.getDefault(<span class="keyword">this</span>),</span><br><span class="line">            mCanBusErrorNotifier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    mICarImpl.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ICarImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ICarImpl</span><span class="params">(Context serviceContext, IVehicle vehicle, SystemInterface systemInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">        CanBusErrorNotifier errorNotifier)</span> </span>&#123;</span><br><span class="line">    mHal = <span class="keyword">new</span> VehicleHal(vehicle);</span><br><span class="line">    mCarRadioService = <span class="keyword">new</span> CarRadioService(serviceContext, mHal.getRadioHal());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Be careful with order. Service depending on other service should be inited later.</span></span><br><span class="line">    List&lt;CarServiceBase&gt; allServices = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(</span><br><span class="line">            mCarRadioService</span><br><span class="line">    ));</span><br><span class="line">    mAllServices = allServices.toArray(<span class="keyword">new</span> CarServiceBase[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">    mHal.init();</span><br><span class="line">    <span class="comment">// 11</span></span><br><span class="line">    <span class="keyword">for</span> (CarServiceBase service : mAllServices) &#123;</span><br><span class="line">        service.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VehicleHal.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VehicleHal</span><span class="params">(IVehicle vehicle)</span> </span>&#123;</span><br><span class="line">    mRadioHal = <span class="keyword">new</span> RadioHalService(<span class="keyword">this</span>);</span><br><span class="line">    mAllServices.addAll(Arrays.asList(mRadioHal));</span><br><span class="line">    mHalClient = <span class="keyword">new</span> HalClient(vehicle, mHandlerThread.getLooper(), <span class="keyword">this</span> <span class="comment">/*IVehicleCallback*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;VehiclePropConfig&gt; properties;</span><br><span class="line">    properties = <span class="keyword">new</span> HashSet&lt;&gt;(mHalClient.getAllPropConfigs());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (HalServiceBase service: mAllServices) &#123;</span><br><span class="line">        Collection&lt;VehiclePropConfig&gt; taken = service.takeSupportedProperties(properties);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (VehiclePropConfig p: taken) &#123;</span><br><span class="line">                mPropertyHandlers.append(p.prop, service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        properties.removeAll(taken);</span><br><span class="line">        <span class="comment">// 9</span></span><br><span class="line">        service.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12 下面走回调流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// public class VehicleHal extends IVehicleCallback.Stub</span></span><br><span class="line"><span class="comment">// 这个类接受hal层的callback，如果属性值更新了，就会向framework通知，然后在这个地方接收。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPropertyEvent</span><span class="params">(ArrayList&lt;VehiclePropValue&gt; propValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (VehiclePropValue v : propValues) &#123;</span><br><span class="line">        HalServiceBase service = mPropertyHandlers.get(v.prop);</span><br><span class="line">        mServicesToDispatch.add(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (HalServiceBase s : mServicesToDispatch) &#123;</span><br><span class="line">        <span class="comment">// 13</span></span><br><span class="line">        s.handleHalEvents(s.getDispatchList());</span><br><span class="line">        s.getDispatchList().clear();</span><br><span class="line">    &#125;</span><br><span class="line">    mServicesToDispatch.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HalClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4</span></span><br><span class="line">HalClient(IVehicle vehicle, Looper looper, IVehicleCallback callback) &#123;</span><br><span class="line">    mVehicle = vehicle;</span><br><span class="line">    Handler handler = <span class="keyword">new</span> CallbackHandler(looper, callback);</span><br><span class="line">    mInternalCallback = <span class="keyword">new</span> VehicleCallback(handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RadioHalService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 14</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHalEvents</span><span class="params">(List&lt;VehiclePropValue&gt; values)</span> </span>&#123;</span><br><span class="line">    RadioHalService.RadioListener radioListener;</span><br><span class="line">    radioListener = mListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (VehiclePropValue v : values) &#123;</span><br><span class="line">        <span class="comment">// 15</span></span><br><span class="line">        CarRadioEvent radioEvent = createCarRadioEvent(v);</span><br><span class="line">        <span class="comment">// 16</span></span><br><span class="line">        radioListener.onEvent(radioEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CarRadioEvent <span class="title">createCarRadioEvent</span><span class="params">(VehiclePropValue v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (v.prop) &#123;</span><br><span class="line">        <span class="keyword">case</span> VehicleProperty.RADIO_PRESET:</span><br><span class="line">            <span class="keyword">int</span> vecSize = v.value.int32Values.size();</span><br><span class="line"></span><br><span class="line">            Integer intValues[] = <span class="keyword">new</span> Integer[<span class="number">4</span>];</span><br><span class="line">            v.value.int32Values.toArray(intValues);</span><br><span class="line"></span><br><span class="line">            CarRadioPreset preset =</span><br><span class="line">                <span class="keyword">new</span> CarRadioPreset(intValues[<span class="number">0</span>], intValues[<span class="number">1</span>], intValues[<span class="number">2</span>], intValues[<span class="number">3</span>]);</span><br><span class="line">            CarRadioEvent event = <span class="keyword">new</span> CarRadioEvent(CarRadioEvent.RADIO_PRESET, preset);</span><br><span class="line">            <span class="keyword">return</span> event;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(RadioListener listener)</span> </span>&#123;</span><br><span class="line">    mListener = listener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subscribe to all radio properties.</span></span><br><span class="line">    mHal.subscribeProperty(<span class="keyword">this</span>, VehicleProperty.RADIO_PRESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CarRadioService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CarRadioManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 27</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(CarRadioEventListener listener)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> CarNotConnectedException </span>&#123;</span><br><span class="line">        mListener = listener;</span><br><span class="line">        <span class="comment">// 19</span></span><br><span class="line">        mListenerToService = <span class="keyword">new</span> CarRadioEventListenerToService(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 18</span></span><br><span class="line">        mService.registerListener(mListenerToService);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CarRadioEventListenerToService</span> <span class="keyword">extends</span> <span class="title">ICarRadioEventListener</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(CarRadioEvent event)</span> </span>&#123;</span><br><span class="line">        CarRadioManager manager = mManager.get();</span><br><span class="line">        <span class="comment">// 21</span></span><br><span class="line">        manager.handleEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 22</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(CarRadioEvent event)</span> </span>&#123;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(MSG_RADIO_EVENT, event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 23</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventCallbackHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_RADIO_EVENT:</span><br><span class="line">                CarRadioManager mgr = mMgr.get();</span><br><span class="line">                mgr.dispatchEventToClient((CarRadioEvent) msg.obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 24</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchEventToClient</span><span class="params">(CarRadioEvent event)</span> </span>&#123;</span><br><span class="line">    CarRadioEventListener listener;</span><br><span class="line">    <span class="comment">// 25</span></span><br><span class="line">    listener = mListener;</span><br><span class="line">    listener.onEvent(event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CarRadioEventListener.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 26</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarRadioEventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> CarRadioEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="App-调用接口"><a href="#App-调用接口" class="headerlink" title="App 调用接口"></a>App 调用接口</h2><h3 id="初始化-Car-及-CarRadioManager"><a href="#初始化-Car-及-CarRadioManager" class="headerlink" title="初始化 Car 及 CarRadioManager"></a>初始化 Car 及 CarRadioManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Car car;</span><br><span class="line"><span class="keyword">public</span> CarRadioManager carRadioManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    car = Car.createCar(<span class="keyword">this</span>, <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                carRadioManager = (CarRadioManager) car.getCarManager(Car.RADIO_SERVICE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CarNotConnectedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            carRadioManager = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    car.connect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口定义-framework层定义"><a href="#接口定义-framework层定义" class="headerlink" title="接口定义 (framework层定义)"></a>接口定义 (framework层定义)</h3><p>CarRadioManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setPreset</span><span class="params">(CarRadioPreset preset)</span> <span class="keyword">throws</span> IllegalArgumentException,</span></span><br><span class="line"><span class="function">        CarNotConnectedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.setPreset(preset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RadioHalService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setRadioPreset</span><span class="params">(CarRadioPreset preset)</span> </span>&#123;</span><br><span class="line">    mHal.set(VehicleProperty.RADIO_PRESET).to(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">            preset.getPresetNumber(),</span><br><span class="line">            preset.getBand(),</span><br><span class="line">            preset.getChannel(),</span><br><span class="line">            preset.getSubChannel()&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">VehicleHal.java</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="meta">@CheckResult</span></span><br><span class="line"><span class="function">VehiclePropValueSetter <span class="title">set</span><span class="params">(<span class="keyword">int</span> propId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VehiclePropValueSetter(mHalClient, propId, NO_AREA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">to</span><span class="params">(<span class="keyword">int</span>[] values)</span> <span class="keyword">throws</span> PropertyTimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : values) &#123;</span><br><span class="line">        mPropValue.value.int32Values.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> <span class="keyword">throws</span> PropertyTimeoutException </span>&#123;</span><br><span class="line">    HalClient client =  mClient.get();</span><br><span class="line">    client.setValue(mPropValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HalClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(VehiclePropValue propValue)</span> <span class="keyword">throws</span> PropertyTimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = invokeRetriable(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mVehicle.set(propValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.e(CarLog.TAG_HAL, <span class="string">"Failed to set value"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> StatusCode.TRY_AGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, WAIT_CAP_FOR_RETRIABLE_RESULT_MS, SLEEP_BETWEEN_RETRIABLE_INVOKES_MS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StatusCode.INVALID_ARG == status) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"Failed to set value for: 0x%x, areaId: 0x%x"</span>,</span><br><span class="line">                        propValue.prop, propValue.areaId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StatusCode.TRY_AGAIN == status) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyTimeoutException(propValue.prop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StatusCode.OK != status) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                String.format(<span class="string">"Failed to set property: 0x%x, areaId: 0x%x, "</span></span><br><span class="line">                        + <span class="string">"code: %d"</span>, propValue.prop, propValue.areaId, status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hardware:<br><!-- android.hardware.automotive.vehicle.V2_0.IVehicle --></p><h2 id="模拟器如何做调试"><a href="#模拟器如何做调试" class="headerlink" title="模拟器如何做调试"></a>模拟器如何做调试</h2><ol><li><p>编译 Car 版本的 harware 源码，及 CarService Apk<br>注：Genymotion pixel xl 对应的是 marlin 版本， 编译出来是64位不能用，所以需要编译 x86 版本，为32位的</p></li><li><p>将编译生成的三个库文件导入模拟器相应位置。</p></li></ol><p>Z:\SourceCode\android-8.0.0_r1\out\target\product\generic_x86\system\vendor\etc\init<br><a href="mailto:android.hardware.automotive.vehicle@2.0-service.rc" target="_blank" rel="noopener">android.hardware.automotive.vehicle@2.0-service.rc</a></p><p>Z:\SourceCode\android-8.0.0_r1\out\target\product\generic_x86\system\vendor\bin\hw<br><a href="mailto:android.hardware.automotive.vehicle@2.0-service" target="_blank" rel="noopener">android.hardware.automotive.vehicle@2.0-service</a></p><p>Z:\SourceCode\android-8.0.0_r1\out\target\product\generic_x86\system\lib<br><a href="mailto:android.hardware.automotive.vehicle@2.0.so" target="_blank" rel="noopener">android.hardware.automotive.vehicle@2.0.so</a></p><ol start="3"><li>安装 CarService apk</li></ol>]]></content>
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Radio </tag>
            
            <tag> CarService </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fragment 详解</title>
      <link href="/2019/02/26/Fragment-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/26/Fragment-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="Fragment-详解"><a href="#Fragment-详解" class="headerlink" title="Fragment 详解"></a>Fragment 详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Fragment(碎片)功能，它非常类似于Activity，可以像Activity一样包含布局，Fragment通常是嵌套在Activity中使用的。<br>Activity一方面需要在布局中为Fragment安排位置，另一方面需要管理好Fragment的生命周期。Activity中有个FragmentManager，其内部维护fragment队列，以及fragment事务的回退栈。</p><a id="more"></a><p><img src="/images/fragment_activity.jpg" alt="fragment_activity嵌套"></p><h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p>Fragment必须是依存与Activity而存在的，因此Activity的生命周期会直接影响到Fragment的生命周期。</p><p><img src="/images/fragment_lifecycle.jpg" alt="fragment生命周期"></p><h2 id="Fragment的静态使用"><a href="#Fragment的静态使用" class="headerlink" title="Fragment的静态使用"></a>Fragment的静态使用</h2><p>把Fragment当成普通的控件，直接写在Activity的布局文件中。</p><ol><li>继承Fragment，重写onCreateView决定Fragemnt的布局</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment_title, container, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在Activity 布局文件中中声明此Fragment，就当和普通的View一样</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_fragment_title"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.test.TitleFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Fragment的动态使用"><a href="#Fragment的动态使用" class="headerlink" title="Fragment的动态使用"></a>Fragment的动态使用</h2><ol><li>继承Fragment，重写onCreateView决定Fragemnt的布局</li></ol><p>同静态使用步骤1.</p><ol start="2"><li>在Actvity的布局文件，中间使用一个FrameLayout</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">"@id/id_ly_bottombar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@id/id_fragment_title"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 Activity 的类文件中，动态的添加、更新、以及删除Fragment</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDefaultFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">    FragmentTransaction transaction = fm.beginTransaction();</span><br><span class="line">    titleFragment = <span class="keyword">new</span> TitleFragment();</span><br><span class="line">    transaction.replace(R.id.id_content, titleFragment);</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment-常用-API"><a href="#Fragment-常用-API" class="headerlink" title="Fragment 常用 API"></a>Fragment 常用 API</h2><h3 id="Fragment-常用的三个类"><a href="#Fragment-常用的三个类" class="headerlink" title="Fragment 常用的三个类"></a>Fragment 常用的三个类</h3><p>Fragment 主要用于定义Fragment<br>FragmentManager 主要用于在Activity中操作Fragment<br>FragmentTransaction 保证一些列Fragment操作的原子性</p><h3 id="获取FragmentManager的方式"><a href="#获取FragmentManager的方式" class="headerlink" title="获取FragmentManager的方式"></a>获取FragmentManager的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSupportFragmentManager()</span><br></pre></td></tr></table></figure><h3 id="主要的操作都是FragmentTransaction的方法"><a href="#主要的操作都是FragmentTransaction的方法" class="headerlink" title="主要的操作都是FragmentTransaction的方法"></a>主要的操作都是FragmentTransaction的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction transaction = fm.benginTransatcion();<span class="comment">//开启一个事务</span></span><br><span class="line">transaction.add()</span><br><span class="line">transaction.remove()</span><br><span class="line">transaction.replace()</span><br><span class="line">transaction.hide()</span><br><span class="line">transaction.show()</span><br><span class="line">detach()</span><br><span class="line">attach()</span><br></pre></td></tr></table></figure><ol><li><p>我在FragmentA中的EditText填了一些数据，当切换到FragmentB时，如果希望会到A还能看到数据，则适合你的就是hide和show；也就是说，希望保留用户操作的面板，你可以使用hide和show，当然了不要使劲在那new实例，进行下非null判断。</p></li><li><p>再比如：我不希望保留用户操作，你可以使用remove()，然后add()；或者使用replace()这个和remove,add是相同的效果。</p></li><li><p>remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用detach。</p></li></ol><h2 id="管理Fragment回退栈"><a href="#管理Fragment回退栈" class="headerlink" title="管理Fragment回退栈"></a>管理Fragment回退栈</h2><p>可以通过Activity维护一个回退栈来保存每次Fragment事务发生的变化。如果你将Fragment任务添加到回退栈，当用户点击后退按钮时，将看到上一次的保存的Fragment。一旦Fragment完全从后退栈中弹出，用户再次点击后退键，则退出当前Activity。</p><p>添加一个Fragment事务到回退栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction.addToBackStack(String)</span><br></pre></td></tr></table></figure><ol><li>Activity 添加默认的Fragment</li></ol><p>这里不调用 addToBackStack，是考虑到点击back时，不想显示白班</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">FragmentTransaction tx = fm.beginTransaction();</span><br><span class="line">tx.add(R.id.id_content, <span class="keyword">new</span> FragmentOne(),<span class="string">"ONE"</span>);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><ol start="2"><li>FragmentOne 中添加点击跳转到 FragmentTwo</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentOne</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Button mBtn;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">View view = inflater.inflate(R.layout.fragment_one, container, <span class="keyword">false</span>);</span><br><span class="line">mBtn = (Button) view.findViewById(R.id.id_fragment_one_btn);</span><br><span class="line">mBtn.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">FragmentTwo fTwo = <span class="keyword">new</span> FragmentTwo();</span><br><span class="line">FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">FragmentTransaction tx = fm.beginTransaction();</span><br><span class="line">tx.replace(R.id.id_content, fTwo, <span class="string">"TWO"</span>);</span><br><span class="line">tx.addToBackStack(<span class="keyword">null</span>); </span><br><span class="line">tx.commit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replace是remove和add的合体，并且如果不添加事务到回退栈，前一个Fragment实例会被销毁。这里很明显，我们调用tx.addToBackStack(null);将当前的事务添加到了回退栈，所以FragmentOne实例不会被销毁，但是视图层次依然会被销毁，即会调用onDestoryView和onCreateView</p><h2 id="Fragment与Activity通信"><a href="#Fragment与Activity通信" class="headerlink" title="Fragment与Activity通信"></a>Fragment与Activity通信</h2><ol><li><p>如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法</p></li><li><p>如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getSupportFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作。</p></li><li><p>在Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作。</p></li></ol><h2 id="Fragment与Activity通信的最佳实践"><a href="#Fragment与Activity通信的最佳实践" class="headerlink" title="Fragment与Activity通信的最佳实践"></a>Fragment与Activity通信的最佳实践</h2><p>要考虑Fragment的重复使用，所以必须降低Fragment与Activity的耦合，而且Fragment更不应该直接操作别的Fragment，毕竟Fragment操作应该由它的管理者Activity来决定。</p><ol><li><p>FragmentOne不和任何Activity耦合，任何Activity都可以使用；并且我们声明了一个接口，来回调其点击事件，想要管理其点击事件的Activity实现此接口就即可。可以看到我们在onClick中首先判断了当前绑定的Activity是否实现了该接口，如果实现了则调用。</p></li><li><p>FragmentOne 中定义接口，来回调点击事件</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> FTwoBtnClickListener fTwoBtnClickListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FTwoBtnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFTwoBtnClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFTwoBtnClickListener</span><span class="params">(FTwoBtnClickListener fTwoBtnClickListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fTwoBtnClickListener = fTwoBtnClickListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mBtn.setOnClickListener(v -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(fTwoBtnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fTwoBtnClickListener.onFTwoBtnClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>Activity 中 设置接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fragmentOne.setFTwoBtnClickListener(<span class="keyword">new</span> FTwoBtnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFOneBtnClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFTwo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFTwo = <span class="keyword">new</span> FragmentTwo();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">        FragmentTransaction tx = fm.beginTransaction();</span><br><span class="line">        tx.replace(R.id.id_content, mFTwo, <span class="string">"TWO"</span>);</span><br><span class="line">        tx.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">        tx.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="处理运行时配置发生变化"><a href="#处理运行时配置发生变化" class="headerlink" title="处理运行时配置发生变化"></a>处理运行时配置发生变化</h2><p>运行时配置发生变化，最常见的就是屏幕发生旋转（或者app放后台过长时间），如果你不知道如何处理屏幕变化可以参考：</p><p><a href="https://blog.csdn.net/lmj623565791/article/details/37936275" target="_blank" rel="noopener">Android 屏幕旋转 处理 AsyncTask 和 ProgressDialog 的最佳方案</a></p><ol><li>原本的Activity:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    mFOne = <span class="keyword">new</span> FragmentOne();</span><br><span class="line">    FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">    FragmentTransaction tx = fm.beginTransaction();</span><br><span class="line">    tx.add(R.id.id_content, mFOne, <span class="string">"ONE"</span>);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次屏幕旋转时，都会重新创建 FragmentOne, 并叠加显示，显然有问题。</p><ol start="2"><li>修改后的Activity</li></ol><p>2.1 可以这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    Log.e(TAG, savedInstanceState+<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span>(savedInstanceState == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mFOne = <span class="keyword">new</span> FragmentOne();</span><br><span class="line">        FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">        FragmentTransaction tx = fm.beginTransaction();</span><br><span class="line">        tx.add(R.id.id_content, mFOne, <span class="string">"ONE"</span>);</span><br><span class="line">        tx.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实通过检查onCreate的参数Bundle savedInstanceState就可以判断，当前是否发生Activity的重新创建, 默认的savedInstanceState会存储一些数据，包括Fragment的实例。<br>所以，只有在savedInstanceState==null时，才进行创建Fragment实例。</p><p>2.2 或者可以这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">    mContentFragment = (ContentFragment) fm.findFragmentById(R.id.id_fragment_container);</span><br><span class="line">    <span class="keyword">if</span>(mContentFragment == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        mContentFragment = <span class="keyword">new</span> ContentFragment();</span><br><span class="line">        fm.beginTransaction().add(R.id.id_fragment_container,mContentFragment).commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Activity因为配置发生改变（屏幕旋转）或者内存不足被系统杀死，造成重新创建时，我们的fragment会被保存下来，但是会创建新的FragmentManager，新的FragmentManager会首先会去获取保存下来的fragment队列，重建fragment队列，从而恢复之前的状态。</p><ol start="3"><li>重新绘制时，Fragment也发生重建</li></ol><p>和Activity类似，Fragment也有onSaveInstanceState的方法，在此方法中进行保存数据，然后在onCreate或者onCreateView或者onActivityCreated进行恢复都可以。</p><h2 id="没有布局的Fragment的作用"><a href="#没有布局的Fragment的作用" class="headerlink" title="没有布局的Fragment的作用"></a>没有布局的Fragment的作用</h2><p>没有布局文件Fragment实际上是为了保存，当Activity重启时，保存大量数据准备的。</p><ol><li><p>继承Fragment，声明需保存状态的对象</p></li><li><p>在 Fragment 创建时，调用 setRetainInstance(true);</p></li><li><p>在 Activity 中创建 Fragment 实例</p></li><li><p>当Activity重新启动后，使用FragmentManager对Fragment进行恢复, 并取出数据</p></li></ol><p>Fragment.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetainedFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap data;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        setRetainInstance(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Bitmap data)</span> </span>&#123; <span class="keyword">this</span>.data = data; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">private</span> RetainedFragment dataFragment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">    dataFragment = (RetainedFragment) fm.findFragmentByTag(<span class="string">"data"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dataFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dataFragment = <span class="keyword">new</span> RetainedFragment();</span><br><span class="line">        fm.beginTransaction().add(dataFragment, <span class="string">"data"</span>).commit();</span><br><span class="line">    &#125;</span><br><span class="line">    data = dataFragment.getData();</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123; initData(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    dataFragment.setData(mBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Fragment创建对话框"><a href="#使用Fragment创建对话框" class="headerlink" title="使用Fragment创建对话框"></a>使用Fragment创建对话框</h2><p><a href="https://github.com/Mcl-123/DialogFragmentDemo" target="_blank" rel="noopener">DialogFragmentDemo</a></p><h2 id="Fragment-Arguments"><a href="#Fragment-Arguments" class="headerlink" title="Fragment Arguments"></a>Fragment Arguments</h2><p>我们某个按钮触发Activity跳转，需要通过Intent传递参数到目标Activity的Fragment中，那么此Fragment如何获取当前的Intent的值？</p><p>Fragment 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mArgument = getActivity().getIntent().getStringExtra(ARGUMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在一个大问题：我们用Fragment的一个很大的原因，就是为了复用。你这么写，相当于这个Fragment已经完全和当前这个宿主Activity绑定了，复用直接废了，所以改用下面的方法：</p><p>Fragment 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    Bundle bundle = getArguments();</span><br><span class="line">    <span class="keyword">if</span> (bundle != <span class="keyword">null</span>) &#123; mArgument = bundle.getString(ARGUMENT); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ContentFragment <span class="title">newInstance</span><span class="params">(String argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    bundle.putString(ARGUMENT, argument);</span><br><span class="line">    ContentFragment contentFragment = <span class="keyword">new</span> ContentFragment();</span><br><span class="line">    contentFragment.setArguments(bundle);</span><br><span class="line">    <span class="keyword">return</span> contentFragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：setArguments方法必须在fragment创建以后，添加给Activity前完成。千万不要，首先调用了add，然后设置arguments</p><h2 id="Fragment的startActivityForResult"><a href="#Fragment的startActivityForResult" class="headerlink" title="Fragment的startActivityForResult"></a>Fragment的startActivityForResult</h2><p>在Fragment中存在startActivityForResult（）以及onActivityResult（）方法，但是呢，没有setResult（）方法，用于设置返回的intent，这样我们就需要通过调用getActivity().setResult(ListTitleFragment.REQUEST_DETAIL, intent);</p><h2 id="SingleFragmentActivity"><a href="#SingleFragmentActivity" class="headerlink" title="SingleFragmentActivity"></a>SingleFragmentActivity</h2><p>抽象BaseFragmentActivigty类： SingleFragmentActivity.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleFragmentActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Fragment <span class="title">createFragment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_single_fragment);</span><br><span class="line"></span><br><span class="line">FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">Fragment fragment =fm.findFragmentById(R.id.id_fragment_container);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fragment == <span class="keyword">null</span> )</span><br><span class="line">&#123;</span><br><span class="line">fragment = createFragment() ;</span><br><span class="line"></span><br><span class="line">fm.beginTransaction().add(R.id.id_fragment_container,fragment).commit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>activity_single_fragment.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/id_fragment_container"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ContentActivity.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentActivity</span> <span class="keyword">extends</span> <span class="title">SingleFragmentActivity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ContentFragment mContentFragment;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Fragment <span class="title">createFragment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String title = getIntent().getStringExtra(ContentFragment.ARGUMENT);</span><br><span class="line"> </span><br><span class="line">mContentFragment = ContentFragment.newInstance(title);</span><br><span class="line"><span class="keyword">return</span> mContentFragment;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContentFragment.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> String mArgument;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARGUMENT = <span class="string">"argument"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESPONSE = <span class="string">"response"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">Bundle bundle = getArguments();</span><br><span class="line"><span class="keyword">if</span> (bundle != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">mArgument = bundle.getString(ARGUMENT);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(RESPONSE, <span class="string">"good"</span>);</span><br><span class="line">getActivity().setResult(ListTitleFragment.REQUEST_DETAIL, intent);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ContentFragment <span class="title">newInstance</span><span class="params">(String argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(ARGUMENT, argument);</span><br><span class="line">ContentFragment contentFragment = <span class="keyword">new</span> ContentFragment();</span><br><span class="line">contentFragment.setArguments(bundle);</span><br><span class="line"><span class="keyword">return</span> contentFragment;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">Bundle savedInstanceState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">TextView tv = <span class="keyword">new</span> TextView(getActivity());</span><br><span class="line">tv.setText(mArgument);</span><br><span class="line">tv.setGravity(Gravity.CENTER);</span><br><span class="line">tv.setBackgroundColor(Color.argb(random.nextInt(<span class="number">100</span>),</span><br><span class="line">random.nextInt(<span class="number">255</span>), random.nextInt(<span class="number">255</span>), random.nextInt(<span class="number">255</span>)));</span><br><span class="line"><span class="keyword">return</span> tv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FragmentPagerAdapter与FragmentStatePagerAdapter"><a href="#FragmentPagerAdapter与FragmentStatePagerAdapter" class="headerlink" title="FragmentPagerAdapter与FragmentStatePagerAdapter"></a>FragmentPagerAdapter与FragmentStatePagerAdapter</h2><p>FragmentPagerAdapter：对于不再需要的fragment，选择调用detach方法，仅销毁视图，并不会销毁fragment实例。</p><p>FragmentStatePagerAdapter：会销毁不再需要的fragment，当当前事务提交以后，会彻底的将fragmeng从当前Activity的FragmentManager中移除，state标明，销毁时，会将其onSaveInstanceState(Bundle outState)中的bundle信息保存下来，当用户切换回来，可以通过该bundle恢复生成新的fragment，也就是说，你可以在onSaveInstanceState(Bundle outState)方法中保存一些数据，在onCreate中进行恢复创建。</p><h2 id="Fragment间的数据传递"><a href="#Fragment间的数据传递" class="headerlink" title="Fragment间的数据传递"></a>Fragment间的数据传递</h2><p>情况：两个Fragment在同一个Activity中：例如，点击当前Fragment中按钮，弹出一个对话框（DialogFragment），在对话框中的操作需要返回给触发的Fragment中</p><p>ContentFragment.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开 DialogFragment</span></span><br><span class="line">tv.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        EvaluateDialog dialog = <span class="keyword">new</span> EvaluateDialog();</span><br><span class="line">        <span class="comment">//注意setTargetFragment</span></span><br><span class="line">        dialog.setTargetFragment(ContentFragment.<span class="keyword">this</span>, REQUEST_EVALUATE);</span><br><span class="line">        dialog.show(getSupportFragmentManager(), EVALUATE_DIALOG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收返回回来的数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestCode == REQUEST_EVALUATE)</span><br><span class="line">    &#123;</span><br><span class="line">        String evaluate = data</span><br><span class="line">                .getStringExtra(EvaluateDialog.RESPONSE_EVALUATE);</span><br><span class="line">        Toast.makeText(getActivity(), evaluate, Toast.LENGTH_SHORT).show();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.putExtra(RESPONSE, evaluate);</span><br><span class="line">        getActivity().setResult(Activity.REQUEST_OK, intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EvaluateDialog.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(<span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否设置了targetFragment</span></span><br><span class="line">    <span class="keyword">if</span> (getTargetFragment() == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.putExtra(RESPONSE_EVALUATE, mEvaluteVals[which]);</span><br><span class="line">    getTargetFragment().onActivityResult(ContentFragment.REQUEST_EVALUATE,</span><br><span class="line">            Activity.RESULT_OK, intent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fragment </tag>
            
            <tag> DialogFragment </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NavigationBar 分析</title>
      <link href="/2019/02/24/aosp-NavigationBar-%E5%88%86%E6%9E%90/"/>
      <url>/2019/02/24/aosp-NavigationBar-%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="NavigationBar-分析"><a href="#NavigationBar-分析" class="headerlink" title="NavigationBar 分析"></a>NavigationBar 分析</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Android手机可分为有导航栏以及没导航栏两种，一般有物理按键的机器不会带有导航栏，而没有物理按键的机器则基本会带。这里主要是分析导航栏导航栏的加载以及按键实现。</p><a id="more"></a><h2 id="导航栏的加载以及按键实现"><a href="#导航栏的加载以及按键实现" class="headerlink" title="导航栏的加载以及按键实现"></a>导航栏的加载以及按键实现</h2><p>导航栏是属于系统界面的一部分，也就是SystemUI的一部分。</p><p>StatusBar.java：</p><p>makeStatusBarView():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> showNav = mWindowManagerService.hasNavigationBar();</span><br><span class="line"><span class="keyword">if</span> (showNav) &#123;</span><br><span class="line">    createNavigationBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createNavigationBar():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mNavigationBarView = NavigationBarFragment.create(mContext, (tag, fragment) -&gt; &#123;</span><br><span class="line">            mNavigationBar = (NavigationBarFragment) fragment;</span><br><span class="line">            <span class="keyword">if</span> (mLightBarController != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mNavigationBar.setLightBarController(mLightBarController);</span><br><span class="line">            &#125;</span><br><span class="line">            mNavigationBar.setCurrentSysuiVisibility(mSystemUiVisibility);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>NavigationBarFragment.java:</p><p>onCreate():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflater.inflate(R.layout.navigation_bar, container, <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>navigation_bar.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.NavigationBarView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:systemui</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/system_bar_background"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.NavigationBarInflaterView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/navigation_inflater"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.phone.NavigationBarView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>NavigationBarView.java: // mRecentIcon</p><p>onFinishInflate():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mNavigationInflaterView = (NavigationBarInflaterView) findViewById(</span><br><span class="line">                R.id.navigation_inflater);</span><br></pre></td></tr></table></figure><p>NavigationBarInflaterView.java:</p><p>onFinishInflate():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflateLayout(getDefaultLayout());</span><br></pre></td></tr></table></figure><p>inflateButtons():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">    inflateButton(buttons[i], parent, landscape);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inflateButton():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View v = createView(buttonSpec, parent, inflater, landscape);</span><br></pre></td></tr></table></figure><p>createView():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (HOME.equals(button)) &#123;</span><br><span class="line">    v = inflater.inflate(R.layout.home, parent, <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (BACK.equals(button)) &#123;</span><br><span class="line">    v = inflater.inflate(R.layout.back, parent, <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (RECENT.equals(button)) &#123;</span><br><span class="line">    v = inflater.inflate(R.layout.recent_apps, parent, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.android.systemui.statusbar.policy.KeyButtonView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:systemui</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/home"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"@dimen/navigation_key_width"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">systemui:keyCode</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:scaleType</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:contentDescription</span>=<span class="string">"@string/accessibility_home"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingStart</span>=<span class="string">"@dimen/navigation_key_padding"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingEnd</span>=<span class="string">"@dimen/navigation_key_padding"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>KeyButtonView.java:</p><p>KeyButtonView():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为home以及id为back的KeyButtonView就分别通过systemui:keyCode属性对其进行了设置，设置的值分别是3和4</span></span><br><span class="line">mCode = a.getInteger(R.styleable.KeyButtonView_keyCode, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>onTouchEvent():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当mCode为0的时候，KeyButtonView并不会调用sendEvent方法</span></span><br><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">        mDownTime = SystemClock.uptimeMillis();</span><br><span class="line">        mLongClicked = <span class="keyword">false</span>;</span><br><span class="line">        setPressed(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (mCode != <span class="number">0</span>) &#123;</span><br><span class="line">            sendEvent(KeyEvent.ACTION_DOWN, <span class="number">0</span>, mDownTime);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Provide the same haptic feedback that the system offers for virtual keys.</span></span><br><span class="line">            performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">        setPressed(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (mCode != <span class="number">0</span>) &#123;</span><br><span class="line">            sendEvent(KeyEvent.ACTION_UP, KeyEvent.FLAG_CANCELED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        <span class="keyword">if</span> (mCode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (doIt) &#123;</span><br><span class="line">                sendEvent(KeyEvent.ACTION_UP, <span class="number">0</span>);</span><br><span class="line">                sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendEvent(KeyEvent.ACTION_UP, KeyEvent.FLAG_CANCELED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no key code, just a regular ImageView</span></span><br><span class="line">            <span class="keyword">if</span> (doIt &amp;&amp; mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">                sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendEvent():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mMetricsLogger.write(<span class="keyword">new</span> LogMaker(MetricsEvent.ACTION_NAV_BUTTON_EVENT)</span><br><span class="line">        .setType(MetricsEvent.TYPE_ACTION)</span><br><span class="line">        .setSubtype(mCode)</span><br><span class="line">        .addTaggedData(MetricsEvent.FIELD_NAV_ACTION, action)</span><br><span class="line">        .addTaggedData(MetricsEvent.FIELD_FLAGS, flags));</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> repeatCount = (flags &amp; KeyEvent.FLAG_LONG_PRESS) != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> KeyEvent ev = <span class="keyword">new</span> KeyEvent(mDownTime, when, action, mCode, repeatCount,</span><br><span class="line">        <span class="number">0</span>, KeyCharacterMap.VIRTUAL_KEYBOARD, <span class="number">0</span>,</span><br><span class="line">        flags | KeyEvent.FLAG_FROM_SYSTEM | KeyEvent.FLAG_VIRTUAL_HARD_KEY,</span><br><span class="line">        InputDevice.SOURCE_KEYBOARD);</span><br><span class="line"><span class="comment">// 构建出一个对应的keyCode的KeyEvent ev，然后调用InputManager的injectInputEvent模拟发送来实现与物理按键相同的功能</span></span><br><span class="line">InputManager.getInstance().injectInputEvent(ev,</span><br><span class="line">        InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);</span><br></pre></td></tr></table></figure><p>NavigationBarFragment.java:</p><p>onViewCreated():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepareNavigationBarView();</span><br></pre></td></tr></table></figure><p>prepareNavigationBarView():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ButtonDispatcher recentsButton = mNavigationBarView.getRecentsButton();</span><br><span class="line">recentsButton.setOnClickListener(<span class="keyword">this</span>::onRecentsClick);</span><br></pre></td></tr></table></figure><p>onRecentsClick():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onRecentsClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    mStatusBar.awakenDreams();</span><br><span class="line">    mCommandQueue.toggleRecentApps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="App实现隐藏导航栏-沉浸式"><a href="#App实现隐藏导航栏-沉浸式" class="headerlink" title="App实现隐藏导航栏(沉浸式)"></a>App实现隐藏导航栏(沉浸式)</h2><p>MainActivity.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    <span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">        View decorView = getWindow().getDecorView();</span><br><span class="line">        decorView.setSystemUiVisibility(</span><br><span class="line">                View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br><span class="line">                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</span><br><span class="line">                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> NavigationBar </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BroadcastReceiver 静态注册与动态注册</title>
      <link href="/2019/02/21/BroadcastReceiver-%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/"/>
      <url>/2019/02/21/BroadcastReceiver-%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/</url>
      <content type="html"><![CDATA[<p>上篇文章提到了 使用自定义uri用于外部启动 app，而我们也可以使用广播来启动外部app，这篇文章简单的介绍下android广播的使用。</p><h1 id="BroadcastReceiver-静态注册与动态注册"><a href="#BroadcastReceiver-静态注册与动态注册" class="headerlink" title="BroadcastReceiver 静态注册与动态注册"></a>BroadcastReceiver 静态注册与动态注册</h1><h2 id="接收广播"><a href="#接收广播" class="headerlink" title="接收广播"></a>接收广播</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  UI 线程，不建议过多操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐, 见Context 干货：(https://www.jianshu.com/p/881acfafd18d)</span></span><br><span class="line">        <span class="comment">// activityIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"music"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    IntentFilter filter=<span class="keyword">new</span> IntentFilter(<span class="string">"music"</span>);</span><br><span class="line">    mBroadcast =<span class="keyword">new</span> MyReceiver();</span><br><span class="line">    registerReceiver(mBroadcast,filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    unregisterReceiver(mBroadcast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"music"</span>);</span><br><span class="line"><span class="comment">// 8.0后，静态注册广播接收者时，需 setComponent()</span></span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.pvwav.broadcastreceiver"</span>, <span class="string">"com.example.pvwav.broadcastreceiver.MyReceiver"</span>));</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> BroadcastReceiver </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义Uri用于外部启动 app</title>
      <link href="/2019/02/20/%E8%87%AA%E5%AE%9A%E4%B9%89Uri%E7%94%A8%E4%BA%8E%E5%A4%96%E9%83%A8%E5%90%AF%E5%8A%A8-app/"/>
      <url>/2019/02/20/%E8%87%AA%E5%AE%9A%E4%B9%89Uri%E7%94%A8%E4%BA%8E%E5%A4%96%E9%83%A8%E5%90%AF%E5%8A%A8-app/</url>
      <content type="html"><![CDATA[<p>项目有个需求，通过语音打开相应的app，例如我说：“去新街口”，就打开高德地图。讯飞语音demo中就有这样的例子，而它就是通过uir实现的。所以在这儿对该实现做了个总结，以便随时之需。</p><h1 id="自定义Uri用于外部启动-app"><a href="#自定义Uri用于外部启动-app" class="headerlink" title="自定义Uri用于外部启动 app"></a>自定义Uri用于外部启动 app</h1><h2 id="新建用于外部启动的Activity"><a href="#新建用于外部启动的Activity" class="headerlink" title="新建用于外部启动的Activity"></a>新建用于外部启动的Activity</h2><p>应用 A：SchemeURL<br>activity: SecondActivity</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=<span class="string">".SecondActivity"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.jackie.schemeurl.activity"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:scheme=<span class="string">"jackie"</span></span><br><span class="line">            android:host=<span class="string">"test.uri.activity"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h2 id="新建启动外部应用的应用"><a href="#新建启动外部应用的应用" class="headerlink" title="新建启动外部应用的应用"></a>新建启动外部应用的应用</h2><p>应用 B：StartSchemeURL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"jackie://test.uri.activity?action=123"</span>); <span class="comment">// action 为传递的数据</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.jackie.schemeurl.activity"</span>);</span><br><span class="line">intent.setData(uri);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><h2 id="通过Uri来传递参数"><a href="#通过Uri来传递参数" class="headerlink" title="通过Uri来传递参数"></a>通过Uri来传递参数</h2><p>应用 A：SchemeURL<br>activity: SecondActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != intent) &#123;</span><br><span class="line">    Uri uri = intent.getData();</span><br><span class="line">    <span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String acionData = uri.getQueryParameter(<span class="string">"action"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> uri </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>链式存储结构与顺序存储结构的区别</title>
      <link href="/2019/02/18/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/02/18/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="链式存储结构与顺序存储结构的区别"><a href="#链式存储结构与顺序存储结构的区别" class="headerlink" title="链式存储结构与顺序存储结构的区别"></a>链式存储结构与顺序存储结构的区别</h1><p>链式存储适用于在较频繁地插入、删除、更新元素，<br>顺序存储结构适用于频繁查询时使用。</p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>链表存储结构的内存地址不一定是连续的，<br>顺序存储结构的内存地址一定是连续的。</p><h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2><p>链式结构每一个节点都有一个指针存储域，所以顺序比链式节约空间，存储空间利用率高。</p><h2 id="插入和删除上"><a href="#插入和删除上" class="headerlink" title="插入和删除上"></a>插入和删除上</h2><p>链式的要比顺序的方便（因为插入的话顺序表也很方便，问题是顺序表的插入要执行更大的空间复杂度，包括一个从表头索引以及索引后的元素后移，而链表是索引后，插入就完成了）</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gradle 离线更新</title>
      <link href="/2019/02/14/Gradle-%E7%A6%BB%E7%BA%BF%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/02/14/Gradle-%E7%A6%BB%E7%BA%BF%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<p>遇到下载的项目，Android studio 一直无法下载成功对应的 gradle 版本，所以选择手动下载 gradle 对应的 zip 文件。</p><ol><li>先到 <a href="http://services.gradle.org/distributions/" target="_blank" rel="noopener">Gradle 官网</a>下载对应的版本 complete 包（all）到本地。</li></ol><p><img src="/images/gradle_download.png" alt="gradle_download"></p><ol start="2"><li>拷贝 gradle-x.x-all.zip 到该目录下:</li></ol><p><img src="/images/gradle_save_location.png" alt="gradle_save_location"></p><p>注意: 1.如果在dists目录下有该gradle版本的文件夹，则拷贝压缩包到该版本文件夹的随机码路径文件夹下。<br>    : 2.否则自己按照之前的对比新建一个文件夹（例如：gradle-4.6-all），然后重新建一个随机码作为名字的文件夹，将gradle-4.6-all.zip拷贝到该目录下。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android studio 无法正常启动</title>
      <link href="/2019/02/13/android-studio-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8/"/>
      <url>/2019/02/13/android-studio-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>手贱！公司电脑升级了最新的 Android Studio，然后启动后就一直停在这个页面上：</p><p><img src="/images/android_studio_无法正常启动.jpeg" alt="android studio 无法正常启动"></p><p>终止进程，重启电脑都试了，没用！</p><p>百度后有几种解决方案：</p><ol><li><p>说没配置好环境变量的（JDK 和SDK）。 可我已经配好了，pass。</p></li><li><p>说内存不足，修改studio64.exe.vmoptions 文件 </p></li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-server</span><br><span class="line"></span><br><span class="line">-Xms256m</span><br><span class="line"></span><br><span class="line">-Xmx768m</span><br><span class="line">-XX:ReservedCodeCacheSize=240m</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=50</span><br><span class="line">-Dsun.io.useCanonCaches=false</span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">-Djna.nosys=true</span><br><span class="line">-Djna.boot.library.path=</span><br></pre></td></tr></table></figure><p>不起作用，pass。</p><ol start="3"><li>打开Android Studio的安装目录下的bin目录，打开idea.properties文件，在最后一行添加“disable.android.first.run=true”。<br>清除android studio的缓存cache，找到文件夹：C:\Users\pvwav.AndroidStudio3.1\system\caches 清空所有，或者删除caches文件夹</li></ol><p>起作用！ OK.</p><p>浪费了很多时间各种试，以后绝不手贱随意升级最新版了！</p>]]></content>
      
      <categories>
          
          <category> Android Studio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>openjdk1.8 切换为 openjdk1.7</title>
      <link href="/2019/01/31/Linux-openjdk1-8-%E5%88%87%E6%8D%A2%E4%B8%BA-openjdk1-7/"/>
      <url>/2019/01/31/Linux-openjdk1-8-%E5%88%87%E6%8D%A2%E4%B8%BA-openjdk1-7/</url>
      <content type="html"><![CDATA[<h1 id="oracle-openjdk-ppa-source"><a href="#oracle-openjdk-ppa-source" class="headerlink" title="oracle openjdk ppa source"></a>oracle openjdk ppa source</h1><p>工作需要编译 Android5.1源码，需要 openjdk1.7 的环境。而工作站上是 openjdk1.8，公司网络又有各种限制，特此分享 oracle openjdk ppa source 的安装切换版本的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-7-jdk</span><br><span class="line"></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line">sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure><p>注：<br>add-apt-repository 是由 python-software-properties 这个工具包提供的<br>所以要先安装python-software-properties 才能使用 add-apt-repository<br>否则会显示“command not found”<br>安装方法：apt-get install python-software-properties<br>sudo apt-get install software-properties-common</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> openjdk </tag>
            
            <tag> ppa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Wallpaper 静态壁纸分析</title>
      <link href="/2019/01/28/aosp-Wallpaper-%E9%9D%99%E6%80%81%E5%A3%81%E7%BA%B8%E5%88%86%E6%9E%90/"/>
      <url>/2019/01/28/aosp-Wallpaper-%E9%9D%99%E6%80%81%E5%A3%81%E7%BA%B8%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>壁纸更新是一个壁纸服务，每换一张壁纸，就是将该图片写入壁纸文件，再启动一个壁纸服务读取该壁纸文件显示出来的过程</p><a id="more"></a><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Android 5.1</p><h1 id="源代码路径"><a href="#源代码路径" class="headerlink" title="源代码路径"></a>源代码路径</h1><p>/frameworks/base/packages/SystemUI/src/com/android/systemui/</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="显示流程"><a href="#显示流程" class="headerlink" title="显示流程"></a>显示流程</h2><p>ImageWallpaper.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default built-in wallpaper that simply shows a static image.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"UnusedDeclaration"</span>&#125;)</span><br><span class="line"><span class="comment">// 继承WallpaperService，随SystemUI 进程启动而启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageWallpaper</span> <span class="keyword">extends</span> <span class="title">WallpaperService</span> </span>&#123;</span><br><span class="line"><span class="comment">// 壁纸加载的真正实现在 Engine中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawableEngine</span> <span class="keyword">extends</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SurfaceHolder surfaceHolder)</span> </span>&#123;</span><br><span class="line">            updateSurfaceSize(surfaceHolder, getDefaultDisplayInfo(), <span class="keyword">false</span> <span class="comment">/* forDraw */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateSurfaceSize()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSurfaceSize</span><span class="params">(SurfaceHolder surfaceHolder)</span> </span>&#123;</span><br><span class="line">    Point p = getDefaultDisplaySize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load background image dimensions, if we haven't saved them yet</span></span><br><span class="line">    <span class="keyword">if</span> (mBackgroundWidth &lt;= <span class="number">0</span> || mBackgroundHeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Need to load the image to get dimensions</span></span><br><span class="line">        mWallpaperManager.forgetLoadedWallpaper();</span><br><span class="line">        <span class="comment">// 加载壁纸图片</span></span><br><span class="line">        updateWallpaperLocked();</span><br><span class="line">        <span class="keyword">if</span> (mBackgroundWidth &lt;= <span class="number">0</span> || mBackgroundHeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Default to the display size if we can't find the dimensions</span></span><br><span class="line">            mBackgroundWidth = p.x;</span><br><span class="line">            mBackgroundHeight = p.y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Force the wallpaper to cover the screen in both dimensions</span></span><br><span class="line">    <span class="keyword">int</span> surfaceWidth = Math.max(p.x, mBackgroundWidth);</span><br><span class="line">    <span class="keyword">int</span> surfaceHeight = Math.max(p.y, mBackgroundHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the surface dimensions haven't changed, then just return</span></span><br><span class="line">    <span class="keyword">final</span> Rect frame = surfaceHolder.getSurfaceFrame();</span><br><span class="line">    <span class="keyword">if</span> (frame != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dw = frame.width();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dh = frame.height();</span><br><span class="line">        <span class="keyword">if</span> (surfaceWidth == dw &amp;&amp; surfaceHeight == dh) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FIXED_SIZED_SURFACE) &#123;</span><br><span class="line">        <span class="comment">// 图片尺寸大则用图片尺寸，屏幕尺寸大则用屏幕尺寸</span></span><br><span class="line">        <span class="comment">// 图片尺寸大时，滑动桌面时壁纸随之而动</span></span><br><span class="line">        <span class="comment">// Used a fixed size surface, because we are special.  We can do</span></span><br><span class="line">        <span class="comment">// this because we know the current design of window animations doesn't</span></span><br><span class="line">        <span class="comment">// cause this to break.</span></span><br><span class="line">        surfaceHolder.setFixedSize(surfaceWidth, surfaceHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        surfaceHolder.setSizeFromLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>updateWallpaperLocked():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateWallpaperLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mBackground = <span class="keyword">null</span>;</span><br><span class="line">        mBackgroundWidth = -<span class="number">1</span>;</span><br><span class="line">        mBackgroundHeight = -<span class="number">1</span>;</span><br><span class="line">        mBackground = mWallpaperManager.getBitmap();</span><br><span class="line">        mBackgroundWidth = mBackground.getWidth();</span><br><span class="line">        mBackgroundHeight = mBackground.getHeight();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackground = <span class="keyword">null</span>;</span><br><span class="line">        mBackgroundWidth = -<span class="number">1</span>;</span><br><span class="line">        mBackgroundHeight = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Note that if we do fail at this, and the default wallpaper can't</span></span><br><span class="line">        <span class="comment">// be loaded, we will go into a cycle.  Don't do a build where the</span></span><br><span class="line">        <span class="comment">// default wallpaper can't be loaded.</span></span><br><span class="line">        Log.w(TAG, <span class="string">"Unable to load wallpaper!"</span>, exception);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mWallpaperManager.clear();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// now we're really screwed.</span></span><br><span class="line">            Log.w(TAG, <span class="string">"Unable reset to default wallpaper!"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getBitmap():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBitmapAsUser(mContext.getUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapAsUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sGlobals.peekWallpaperBitmap(mContext, <span class="keyword">true</span>, FLAG_SYSTEM, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>peekWallpaperBitmap():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">peekWallpaperBitmap</span><span class="params">(Context context, <span class="keyword">boolean</span> returnDefault,</span></span></span><br><span class="line"><span class="function"><span class="params">        @SetWallpaperFlags <span class="keyword">int</span> which, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCachedWallpaper != <span class="keyword">null</span> &amp;&amp; mCachedWallpaperUserId == userId) &#123;</span><br><span class="line">            <span class="keyword">return</span> mCachedWallpaper;</span><br><span class="line">        &#125;</span><br><span class="line">        mCachedWallpaper = <span class="keyword">null</span>;</span><br><span class="line">        mCachedWallpaperUserId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCachedWallpaper = getCurrentWallpaperLocked(userId);</span><br><span class="line">            mCachedWallpaperUserId = userId;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"No memory load current wallpaper"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mCachedWallpaper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mCachedWallpaper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnDefault) &#123;</span><br><span class="line">        <span class="comment">// 如果上面没有得到壁纸资源就在这里取得默认壁纸即路径com.android.internal.R.drawable.default_wallpaper并 把图片写入/data/system/users/&#123;userid&#125;/wallpaper</span></span><br><span class="line">        Bitmap defaultWallpaper = mDefaultWallpaper;</span><br><span class="line">        <span class="keyword">if</span> (defaultWallpaper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            defaultWallpaper = getDefaultWallpaper(context, which);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                mDefaultWallpaper = defaultWallpaper;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultWallpaper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getCurrentWallpaperLocked()：</p><p>// 从路径data//system/users/{userid}/wallpaper取得当前用户壁纸，如果手机不是第一次启动这个一般能取到壁纸资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">getCurrentWallpaperLocked</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"WallpaperService not running"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bundle params = <span class="keyword">new</span> Bundle();</span><br><span class="line">        ParcelFileDescriptor fd = mService.getWallpaper(<span class="keyword">this</span>, FLAG_SYSTEM,</span><br><span class="line">                params, userId);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">                <span class="keyword">return</span> BitmapFactory.decodeFileDescriptor(</span><br><span class="line">                        fd.getFileDescriptor(), <span class="keyword">null</span>, options);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Can't decode file"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>drawFrame():</p><p>得到壁纸图片后开始绘制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> newRotation = ((WindowManager) getSystemService(WINDOW_SERVICE)).</span><br><span class="line">                getDefaultDisplay().getRotation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sometimes a wallpaper is not large enough to cover the screen in one dimension.</span></span><br><span class="line">        <span class="comment">// Call updateSurfaceSize -- it will only actually do the update if the dimensions</span></span><br><span class="line">        <span class="comment">// should change</span></span><br><span class="line">        <span class="keyword">if</span> (newRotation != mLastRotation) &#123;</span><br><span class="line">            <span class="comment">// Update surface size (if necessary)</span></span><br><span class="line">            updateSurfaceSize(getSurfaceHolder());</span><br><span class="line">        &#125;</span><br><span class="line">        SurfaceHolder sh = getSurfaceHolder();</span><br><span class="line">        <span class="keyword">final</span> Rect frame = sh.getSurfaceFrame();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dw = frame.width();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dh = frame.height();</span><br><span class="line">        <span class="keyword">boolean</span> surfaceDimensionsChanged = dw != mLastSurfaceWidth</span><br><span class="line">                || dh != mLastSurfaceHeight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> redrawNeeded = surfaceDimensionsChanged || newRotation != mLastRotation;</span><br><span class="line">        <span class="keyword">if</span> (!redrawNeeded &amp;&amp; !mOffsetsChanged) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastRotation = newRotation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load bitmap if it is not yet loaded or if it was loaded at a different size</span></span><br><span class="line">        <span class="keyword">if</span> (mBackground == <span class="keyword">null</span> || surfaceDimensionsChanged) &#123;</span><br><span class="line">            mWallpaperManager.forgetLoadedWallpaper();</span><br><span class="line">            updateWallpaperLocked();</span><br><span class="line">            <span class="keyword">if</span> (mBackground == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Center the scaled image</span></span><br><span class="line">        mScale = Math.max(<span class="number">1f</span>, Math.max(dw / (<span class="keyword">float</span>) mBackground.getWidth(),</span><br><span class="line">                dh / (<span class="keyword">float</span>) mBackground.getHeight()));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> availw = dw - (<span class="keyword">int</span>) (mBackground.getWidth() * mScale);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> availh = dh - (<span class="keyword">int</span>) (mBackground.getHeight() * mScale);</span><br><span class="line">        <span class="keyword">int</span> xPixels = availw / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> yPixels = availh / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adjust the image for xOffset/yOffset values. If window manager is handling offsets,</span></span><br><span class="line">        <span class="comment">// mXOffset and mYOffset are set to 0.5f by default and therefore xPixels and yPixels</span></span><br><span class="line">        <span class="comment">// will remain unchanged</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> availwUnscaled = dw - mBackground.getWidth();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> availhUnscaled = dh - mBackground.getHeight();</span><br><span class="line">        <span class="keyword">if</span> (availwUnscaled &lt; <span class="number">0</span>)</span><br><span class="line">            xPixels += (<span class="keyword">int</span>) (availwUnscaled * (mXOffset - .<span class="number">5f</span>) + .<span class="number">5f</span>);</span><br><span class="line">        <span class="keyword">if</span> (availhUnscaled &lt; <span class="number">0</span>)</span><br><span class="line">            yPixels += (<span class="keyword">int</span>) (availhUnscaled * (mYOffset - .<span class="number">5f</span>) + .<span class="number">5f</span>);</span><br><span class="line"></span><br><span class="line">        mOffsetsChanged = <span class="keyword">false</span>;</span><br><span class="line">        mRedrawNeeded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (surfaceDimensionsChanged) &#123;</span><br><span class="line">            mLastSurfaceWidth = dw;</span><br><span class="line">            mLastSurfaceHeight = dh;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redrawNeeded &amp;&amp; xPixels == mLastXTranslation &amp;&amp; yPixels == mLastYTranslation) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastXTranslation = xPixels;</span><br><span class="line">        mLastYTranslation = yPixels;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否支持硬件加速</span></span><br><span class="line">        <span class="keyword">if</span> (mIsHwAccelerated) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!drawWallpaperWithOpenGL(sh, availw, availh, xPixels, yPixels)) &#123;</span><br><span class="line">                drawWallpaperWithCanvas(sh, availw, availh, xPixels, yPixels);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drawWallpaperWithCanvas(sh, availw, availh, xPixels, yPixels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (FIXED_SIZED_SURFACE &amp;&amp; !mIsHwAccelerated) &#123;</span><br><span class="line">            <span class="comment">// If the surface is fixed-size, we should only need to</span></span><br><span class="line">            <span class="comment">// draw it once and then we'll let the window manager</span></span><br><span class="line">            <span class="comment">// position it appropriately.  As such, we no longer needed</span></span><br><span class="line">            <span class="comment">// the loaded bitmap.  Yay!</span></span><br><span class="line">            <span class="comment">// hw-accelerated renderer retains bitmap for faster rotation</span></span><br><span class="line">            mBackground = <span class="keyword">null</span>;</span><br><span class="line">            mWallpaperManager.forgetLoadedWallpaper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置流程"><a href="#设置流程" class="headerlink" title="设置流程"></a>设置流程</h2><h3 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.SET_WALLPAPER&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="设置壁纸"><a href="#设置壁纸" class="headerlink" title="设置壁纸"></a>设置壁纸</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WallpaperManager wallpaperManager = WallpaperManager.getInstance(this);</span><br><span class="line">try &#123;</span><br><span class="line">wallpaperManager.setStream(InputStream,null,true,WallpaperManager.FLAG_LOCK);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析设置过程"><a href="#分析设置过程" class="headerlink" title="分析设置过程"></a>分析设置过程</h3><p>setStream():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //sGlobals.mService即WallpaperManagerService</span><br><span class="line">    ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null,</span><br><span class="line">            mContext.getOpPackageName(), visibleCropHint, allowBackup,</span><br><span class="line">            result, which, completion, UserHandle.myUserId());</span><br><span class="line">    if (fd != null) &#123;</span><br><span class="line">        FileOutputStream fos = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 拷贝壁纸图片到壁纸目录</span><br><span class="line">            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);</span><br><span class="line">            copyStreamToWallpaperFile(bitmapData, fos);</span><br><span class="line">            fos.close();</span><br><span class="line">            completion.waitForCompletion();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IoUtils.closeQuietly(fos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (RemoteException e) &#123;</span><br><span class="line">    throw e.rethrowFromSystemServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WallpaperManagerService.java </p><p>setWallpaper():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ParcelFileDescriptor setWallpaper(String name, String callingPackage,</span><br><span class="line">                                            Rect cropHint, boolean allowBackup, Bundle extras, int which,</span><br><span class="line">                                            IWallpaperManagerCallback completion, int userId) &#123;</span><br><span class="line"></span><br><span class="line">    checkPermission(android.Manifest.permission.SET_WALLPAPER);</span><br><span class="line">    if ((which &amp; (FLAG_LOCK|FLAG_SYSTEM)) == 0) &#123;</span><br><span class="line">        final String msg = &quot;Must specify a valid wallpaper category to set&quot;;</span><br><span class="line">        Slog.e(TAG, msg);</span><br><span class="line">        throw new IllegalArgumentException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (which == FLAG_SYSTEM &amp;&amp; mLockWallpaperMap.get(userId) == null) &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Migrating system-&gt;lock to preserve&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        migrateSystemToLockWallpaperLocked(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParcelFileDescriptor pfd = updateWallpaperBitmapLocked(name, wallpaper, extras);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onEvent():</p><p>监听壁纸图片变化的回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void onEvent(int event, String path) &#123;</span><br><span class="line"></span><br><span class="line">    if (sysWallpaperChanged || lockWallpaperChanged) &#123;</span><br><span class="line">        notifyCallbacksLocked(wallpaper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sysWallpaperChanged) &#123;</span><br><span class="line">        //桌面壁纸变化，那么bind ImageWallpaper，ImageWallpaper是负责显示静态桌面壁纸的</span><br><span class="line">        // If this was the system wallpaper, rebind...</span><br><span class="line">        bindWallpaperComponentLocked(mImageWallpaper, true,</span><br><span class="line">                false, wallpaper, null);</span><br><span class="line">        notifyColorsWhich |= FLAG_SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (lockWallpaperChanged</span><br><span class="line">            || (wallpaper.whichPending &amp; FLAG_LOCK) != 0) &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Lock-relevant wallpaper changed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // either a lock-only wallpaper commit or a system+lock event.</span><br><span class="line">        // if it&apos;s system-plus-lock we need to wipe the lock bookkeeping;</span><br><span class="line">        // we&apos;re falling back to displaying the system wallpaper there.</span><br><span class="line">        //如果参数which是system+lock，也就是同时设置锁屏和桌面壁纸，那么remove锁屏壁纸，因为已经是同一张壁纸了</span><br><span class="line">        if (!lockWallpaperChanged) &#123;</span><br><span class="line">            mLockWallpaperMap.remove(wallpaper.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        // and in any case, tell keyguard about it</span><br><span class="line">        notifyLockWallpaperChanged();</span><br><span class="line">        notifyColorsWhich |= FLAG_LOCK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁屏壁纸更新"><a href="#锁屏壁纸更新" class="headerlink" title="锁屏壁纸更新"></a>锁屏壁纸更新</h4><p>notifyLockWallpaperChanged():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void notifyLockWallpaperChanged() &#123;</span><br><span class="line">    final IWallpaperManagerCallback cb = mKeyguardListener;</span><br><span class="line">    if (cb != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            cb.onWallpaperChanged();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            // Oh well it went away; no big deal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockscreenWallpaper.java:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public LockscreenWallpaper(Context ctx, PhoneStatusBar bar, Handler h) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //在这里给mKeyguardListener赋值的</span><br><span class="line">        mService.setLockWallpaperCallback(this);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;System dead?&quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockscreenWallpaper.java onWallpaperChanged:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void onWallpaperChanged() &#123;</span><br><span class="line">    // Called on Binder thread.</span><br><span class="line">    mH.removeCallbacks(this);</span><br><span class="line">    mH.post(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run():</p><p>实现了 runnable 接口，异步获取壁纸图片，更新 statusbar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    // Called in response to onWallpaperChanged on the main thread.</span><br><span class="line">    mLoader = new AsyncTask&lt;Void, Void, LoaderResult&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected LoaderResult doInBackground(Void... params) &#123;</span><br><span class="line">            return loadBitmap(currentUser, selectedUser);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected void onPostExecute(LoaderResult result) &#123;</span><br><span class="line">            super.onPostExecute(result);</span><br><span class="line">            if (isCancelled()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (result.success) &#123;</span><br><span class="line">                mCached = true;</span><br><span class="line">                mCache = result.bitmap;</span><br><span class="line">                mUpdateMonitor.setHasLockscreenWallpaper(result.bitmap != null);</span><br><span class="line">                //通知StatsuBar更新壁纸</span><br><span class="line">                mBar.updateMediaMetaData(</span><br><span class="line">                        true /* metaDataChanged */, true /* allowEnterAnimation */);</span><br><span class="line">            &#125;</span><br><span class="line">            mLoader = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新桌面壁纸"><a href="#更新桌面壁纸" class="headerlink" title="更新桌面壁纸"></a>更新桌面壁纸</h4><p>ImageWallpaper.java bindWallpaperComponentLocked():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> boolean bindWallpaperComponentLocked(ComponentName componentName, boolean force,</span><br><span class="line">                                        boolean fromUser, WallpaperData wallpaper, IRemoteCallback reply) &#123;</span><br><span class="line">    Intent intent = new Intent(WallpaperService.SERVICE_INTERFACE);</span><br><span class="line">    WallpaperConnection newConn = new WallpaperConnection(wi, wallpaper);</span><br><span class="line">    //componentName就是ImageWallpaper</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    intent.putExtra(Intent.EXTRA_CLIENT_LABEL,</span><br><span class="line">            com.android.internal.R.string.wallpaper_binding_label);</span><br><span class="line">    intent.putExtra(Intent.EXTRA_CLIENT_INTENT, PendingIntent.getActivityAsUser(</span><br><span class="line">            mContext, 0,</span><br><span class="line">            Intent.createChooser(new Intent(Intent.ACTION_SET_WALLPAPER),</span><br><span class="line">                    mContext.getText(com.android.internal.R.string.chooser_wallpaper)),</span><br><span class="line">            0, null, new UserHandle(serviceUserId)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WallpaperConnection.java onServiceConnected():</p><p>ImageWallpaper 继承自 service，bindService，所以看 conn 的 onServiceConnected()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mWallpaper.connection == this) &#123;</span><br><span class="line">            mService = IWallpaperService.Stub.asInterface(service);</span><br><span class="line">            attachServiceLocked(this, mWallpaper);</span><br><span class="line">            // XXX should probably do saveSettingsLocked() later</span><br><span class="line">            // when we have an engine, but I&apos;m not sure about</span><br><span class="line">            // locking there and anyway we always need to be able to</span><br><span class="line">            // recover if there is something wrong.</span><br><span class="line">            saveSettingsLocked(mWallpaper.userId);</span><br><span class="line">            FgThread.getHandler().removeCallbacks(mResetRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attachServcieLocked():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void attachServiceLocked(WallpaperConnection conn, WallpaperData wallpaper) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        conn.mService.attach(conn, conn.mToken,</span><br><span class="line">                TYPE_WALLPAPER, false,</span><br><span class="line">                wallpaper.width, wallpaper.height, wallpaper.padding);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Failed attaching wallpaper; clearing&quot;, e);</span><br><span class="line">        if (!wallpaper.wallpaperUpdating) &#123;</span><br><span class="line">            bindWallpaperComponentLocked(null, false, false, wallpaper, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IWallpaperService.Stub attach():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void attach(IWallpaperConnection conn, IBinder windowToken,</span><br><span class="line">        int windowType, boolean isPreview, int reqWidth, int reqHeight, Rect padding) &#123;</span><br><span class="line">    new IWallpaperEngineWrapper(mTarget, conn, windowToken,</span><br><span class="line">            windowType, isPreview, reqWidth, reqHeight, padding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IWallpaperEngineWrapper IWallpaperEngineWrapper()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message msg = mCaller.obtainMessage(DO_ATTACH);</span><br><span class="line">mCaller.sendMessage(msg);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">case DO_ATTACH: &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mConnection.attachEngine(this);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        Log.w(TAG, &quot;Wallpaper host disappeared&quot;, e);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Engine engine = onCreateEngine();</span><br><span class="line">                    mEngine = engine;</span><br><span class="line">                    mActiveEngines.add(engine);</span><br><span class="line">                    engine.attach(this);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>ImageWallpaper.java onCreateEngine():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Engine onCreateEngine() &#123;</span><br><span class="line">    mEngine = new DrawableEngine();</span><br><span class="line">    return mEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Engine.java attach():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void attach(IWallpaperEngineWrapper wrapper) &#123;</span><br><span class="line">      onCreate(mSurfaceHolder);</span><br><span class="line">      mInitializing = false;</span><br><span class="line">      mReportedVisible = false;</span><br><span class="line">      updateSurface(false, false, false);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ImageWallpaper.java onCreate():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void onCreate(SurfaceHolder surfaceHolder) &#123;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onCreate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    super.onCreate(surfaceHolder);</span><br><span class="line">    mDefaultDisplay = getSystemService(WindowManager.class).getDefaultDisplay();</span><br><span class="line">    setOffsetNotificationsEnabled(false);</span><br><span class="line">    updateSurfaceSize(surfaceHolder, getDefaultDisplayInfo(), false /* forDraw */);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateSurfaceSize():</p><p>见流程</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://github.com/Mcl-123/WallpaperDemo" target="_blank" rel="noopener">WallpaperDemo</a></p>]]></content>
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码 </tag>
            
            <tag> Wallpaper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jar、aar 的生成与导入</title>
      <link href="/2019/01/27/jar-aar-%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/27/jar-aar-%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文将介绍 jar、aar 包的生成与导入。</p><a id="more"></a><h1 id="jar-包的生成"><a href="#jar-包的生成" class="headerlink" title="jar 包的生成"></a>jar 包的生成</h1><ol><li>创建一个普通项目My Application。</li><li>新建module：菜单栏 File -&gt; New -&gt; New Module</li><li>选择 Android Librar，并确认。</li><li>菜单栏 File -&gt; Project Structure</li><li>将新建的 module 导入 app 中。</li></ol><p><img src="/images/将module导入app.png" alt="将module导入app"></p><ol start="6"><li><p>修改 module 项目的 build.gradle 文件，添加如下代码： (注意：与 buildTypes 平级)<br> 方式一：打包的 jar 包括 .class 文件及资源文件等</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def _BASENAME = <span class="string">"TestJar"</span></span><br><span class="line">def _VERSION = <span class="string">"_V1.0"</span></span><br><span class="line">def _DestinationPath = <span class="string">"build"</span> <span class="comment">//生成jar包的位置</span></span><br><span class="line">def zipFile = file(<span class="string">'build/intermediates/packaged-classes/release/classes.jar'</span>) <span class="comment">//待打包文件位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">deleteBuild</span><span class="params">(type:Delete)</span></span>&#123;</span><br><span class="line">    delete _DestinationPath + _BASENAME + _VERSION + <span class="string">".jar"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">makeJar</span><span class="params">(type:Jar)</span></span>&#123;</span><br><span class="line">    <span class="function">from <span class="title">zipTree</span><span class="params">(zipFile)</span></span></span><br><span class="line"><span class="function">    from <span class="title">fileTree</span><span class="params">(dir:<span class="string">'src/main'</span>,includes:[<span class="string">'assets/**'</span>])</span> <span class="comment">//将assets目录打入jar包</span></span></span><br><span class="line"><span class="function">    baseName </span>= _BASENAME + _VERSION</span><br><span class="line">    destinationDir = file(_DestinationPath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeJar.dependsOn(deleteBuild, build)</span><br></pre></td></tr></table></figure><p> 方式二：打包的 jar 只有源代码的.class 文件，不包含资源文件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">makeJar</span><span class="params">(type: Copy)</span> </span>&#123;</span><br><span class="line">    delete <span class="string">'build/TestJar_V1.0.jar'</span> <span class="comment">//删除之前的旧jar包</span></span><br><span class="line">    from(<span class="string">'build/intermediates/packaged-classes/release/'</span>) <span class="comment">//从这个目录下取出默认jar包</span></span><br><span class="line">    into(<span class="string">'build/'</span>) <span class="comment">//将jar包输出到指定目录下</span></span><br><span class="line">    include(<span class="string">'classes.jar'</span>)</span><br><span class="line">    rename(<span class="string">'classes.jar'</span>, <span class="string">'TestJar_V1.0.jar'</span>) <span class="comment">//自定义jar包的名字</span></span><br><span class="line">&#125;</span><br><span class="line">makeJar.dependsOn(build)</span><br></pre></td></tr></table></figure></li><li><p>找到 Gradle 中的 makeJar 命令：Gradle 一般在 android studio 右侧，点击，选择 Module 中的 other，找到 makeJar，双击执行。</p></li><li>编译完成后，在对应位置找到生成的 jar 包即可。</li></ol><p><img src="/images/生成jar包位置.png" alt="生成jar包位置"></p><h1 id="jar-包的导入"><a href="#jar-包的导入" class="headerlink" title="jar 包的导入"></a>jar 包的导入</h1><ol><li>将 jar 包拷贝至 app/libs/ 目录下</li><li>右键 jar 包，选择 Add As Library 确认即可。</li></ol><h1 id="aar-包的生成"><a href="#aar-包的生成" class="headerlink" title="aar 包的生成"></a>aar 包的生成</h1><ol><li>同 jar 包的生成步骤中 1-5，新建 module 并导入 app 中。</li><li>找到 Gradle 中的 assembleRelease 命令：Gradle 一般在 android studio 右侧，点击，选择 Module 中的 build，找到 assembleRelease，双击执行。</li></ol><p><img src="/images/assembleRelease.png" alt="assembleRelease"></p><ol start="3"><li>编译成功后，可以在 module 下的 build/outputs/aar/ 目录下看到生成的 aar 文件</li></ol><p><img src="/images/aar生成位置.png" alt="aar生成位置"></p><h1 id="aar-包的导入"><a href="#aar-包的导入" class="headerlink" title="aar 包的导入"></a>aar 包的导入</h1><ol><li>将 jar 包拷贝至 app/libs/ 目录下</li><li>修改 app 下的 build.gradle 文件，添加如下代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 buildTypes 同级</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs <span class="string">'libs'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于 dependencies 下</span></span><br><span class="line">implementation(name:<span class="string">'mylibrary-release'</span>, ext:<span class="string">'aar'</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>重新编译即可</li></ol>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jar </tag>
            
            <tag> aar </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android SystemUI 源码分析</title>
      <link href="/2019/01/27/aosp-SystemUI-%E5%88%86%E6%9E%90/"/>
      <url>/2019/01/27/aosp-SystemUI-%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>因为项目需要，所以对 Android 源码中的 SystemUI 做了点基本分析。</p><a id="more"></a><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>Android 5.1</p><h2 id="源代码路径"><a href="#源代码路径" class="headerlink" title="源代码路径"></a>源代码路径</h2><p>/frameworks/base/packages/SystemUI/src/com/android/systemui/</p><h2 id="什么是SystemUI"><a href="#什么是SystemUI" class="headerlink" title="什么是SystemUI"></a>什么是SystemUI</h2><p>其实就是Android的系统界面，包括状态栏Status Bar，导航栏Navigation Bar，锁屏界面Keyguard，电源界面PowerUI，最近任务管理Recents 等等。</p><p><img src="/images/SystemUI相关类继承关系.jpg" alt="SystemUI相关类继承关系"></p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>SystemServer.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args）&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    startBootstrapServices();  <span class="comment">// 启动系统启动所需的关键服务</span></span><br><span class="line">    startCoreServices();    <span class="comment">// 启动基本服务</span></span><br><span class="line">    startOtherServices();   <span class="comment">// 启动其他服务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            startSystemUi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startSystemUi</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.android.systemui"</span>,</span><br><span class="line">                <span class="string">"com.android.systemui.SystemUIService"</span>));</span><br><span class="line">    context.startServiceAsUser(intent, UserHandle.OWNER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们进入设置启动 systemui 程序的 SystemUIService.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    ((SystemUIApplication) getApplication()).startServicesIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemUIApplication.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt;[] SERVICES = <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">        com.android.systemui.keyguard.KeyguardViewMediator.class,</span><br><span class="line">        com.android.systemui.recent.Recents.class,</span><br><span class="line">        com.android.systemui.volume.VolumeUI.class,</span><br><span class="line">        com.android.systemui.statusbar.SystemBars.class,</span><br><span class="line">        com.android.systemui.usb.StorageNotification.class,</span><br><span class="line">        com.android.systemui.power.PowerUI.class,</span><br><span class="line">        com.android.systemui.media.RingtonePlayer.class</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是拿到每个和 SystemUI 相关的类的反射，存到了 service[] 里，然后赋值给cl，紧接着将通过反射将其转化为具体类的对象，存到了mService[i]数组里，最后对象调 start() 方法启动相关类的服务，启动完成后，回调 onBootCompleted( ) 方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServicesIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = SERVICES.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        Class&lt;?&gt; cl = SERVICES[i];</span><br><span class="line">        mServices[i] = (SystemUI)cl.newInstance();</span><br><span class="line">        mServices[i].mContext = <span class="keyword">this</span>;</span><br><span class="line">        mServices[i].mComponents = mComponents;</span><br><span class="line">        mServices[i].start();</span><br><span class="line">        <span class="keyword">if</span> (mBootCompleted) &#123;</span><br><span class="line">            mServices[i].onBootCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 以 SystemBars 的 start() 为例，所以mService[i].start() 先认为是 SystemBars.start()</p><p>SystemBars.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mServiceMonitor = <span class="keyword">new</span> ServiceMonitor(TAG, DEBUG,</span><br><span class="line">            mContext, Settings.Secure.BAR_SERVICE_COMPONENT, <span class="keyword">this</span>);</span><br><span class="line">    mServiceMonitor.start();  <span class="comment">// will call onNoService if no remote service is found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNoService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createStatusBarFromConfig();  <span class="comment">// fallback to using an in-process implementation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createStatusBarFromConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// R.string.config_statusBarComponent: com.android.systemui.statusbar.phone.PhoneStatusBar</span></span><br><span class="line">    <span class="keyword">final</span> String clsName = mContext.getString(R.string.config_statusBarComponent);</span><br><span class="line">    Class&lt;?&gt; cls = <span class="keyword">null</span>;</span><br><span class="line">    cls = mContext.getClassLoader().loadClass(clsName);</span><br><span class="line">    mStatusBar = (BaseStatusBar) cls.newInstance();</span><br><span class="line">    mStatusBar.mContext = mContext;</span><br><span class="line">    mStatusBar.mComponents = mComponents;</span><br><span class="line">    mStatusBar.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PhoneStatusBar.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.start(); <span class="comment">// calls createAndAddWindows()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAndAddWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addStatusBarWindow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addStatusBarWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    makeStatusBarView();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructing the view</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PhoneStatusBarView <span class="title">makeStatusBarView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mStatusBarWindow = (StatusBarWindowView) View.inflate(context,</span><br><span class="line">            R.layout.super_status_bar, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-super-status-bar-xml-的分析-SystemBars-的大致视图构成了"><a href="#通过-super-status-bar-xml-的分析-SystemBars-的大致视图构成了" class="headerlink" title="通过 super_status_bar.xml 的分析 SystemBars 的大致视图构成了:"></a>通过 super_status_bar.xml 的分析 SystemBars 的大致视图构成了:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.StatusBarWindowView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.BackDropView</span> <span class="attr">android:id</span>=<span class="string">"@+id/backdrop"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:id</span>=<span class="string">"@+id/backdrop_back"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:id</span>=<span class="string">"@+id/backdrop_front"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.BackDropView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.ScrimView</span> <span class="attr">android:id</span>=<span class="string">"@+id/scrim_behind"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 系统状态栏的布局文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/status_bar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/brightness_mirror"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 下拉的通知窗口的布局文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/quick_settings_brightness_dialog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.PanelHolder</span> <span class="attr">android:id</span>=<span class="string">"@+id/panel_holder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/status_bar_expanded"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.phone.PanelHolder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.ScrimView</span> <span class="attr">android:id</span>=<span class="string">"@+id/scrim_in_front"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.phone.StatusBarWindowView</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/super_status_bar.jpg" alt="super_status_bar"></p><h4 id="status-bar"><a href="#status-bar" class="headerlink" title="status_bar"></a>status_bar</h4><p>PhoneStatusBarView 即为手机最上方的状态栏，主要用于显示系统状态，通知等，主要包括 notification icons 和 status bar icons。status_bar.xml 即对应状态栏的视图如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.PhoneStatusBarView</span> <span class="attr">android:id</span>=<span class="string">"@+id/status_bar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:id</span>=<span class="string">"@+id/notification_lights_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/status_bar_contents"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:id</span>=<span class="string">"@+id/status_bar_weather_image"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/status_bar_weather_text"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/status_bar_temperature"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/status_bar_location"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.AlphaOptimizedFrameLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/notification_icon_area"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- The alpha of this area is both controlled from PhoneStatusBarTransitions and</span></span><br><span class="line"><span class="comment">                 PhoneStatusBar (DISABLE_NOTIFICATION_ICONS), so we need two views here. --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.android.keyguard.AlphaOptimizedLinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/notification_icon_area_inner"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.StatusBarIconView</span> <span class="attr">android:id</span>=<span class="string">"@+id/moreIcon"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.IconMerger</span> <span class="attr">android:id</span>=<span class="string">"@+id/notificationIcons"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">com.android.keyguard.AlphaOptimizedLinearLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.AlphaOptimizedFrameLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.android.keyguard.AlphaOptimizedLinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/system_icon_area"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/system_icons"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.policy.Clock</span> <span class="attr">android:id</span>=<span class="string">"@+id/clock"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.android.keyguard.AlphaOptimizedLinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/ticker_stub"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.phone.PhoneStatusBarView</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/status_bar.jpg" alt="status_bar"></p><h4 id="PanelHolder"><a href="#PanelHolder" class="headerlink" title="PanelHolder"></a>PanelHolder</h4><p>PanelHolder是用户下拉 status bar 后得到的 view。它主要包含 QuickSettings 和 Notification panel 两个部分。 </p><p>status_bar_expanded.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.NotificationPanelView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/carrier_label"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/keyguard_status_view"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/emergency_calls_only"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAppearance</span>=<span class="string">"@style/TextAppearance.StatusBar.Expanded.Network.EmergencyOnly"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.NotificationsQuickSettingsContainer</span> <span class="attr">android:id</span>=<span class="string">"@+id/notification_container_parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.phone.ObservableScrollView</span> <span class="attr">android:id</span>=<span class="string">"@+id/scroll_view"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/qs_panel"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">View</span> <span class="attr">android:id</span>=<span class="string">"@+id/reserve_notification_space"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">View</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.phone.ObservableScrollView</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.stack.NotificationStackScrollLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/notification_stack_scroller"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/keyguard_user_switcher"</span> <span class="attr">android:layout</span>=<span class="string">"@layout/keyguard_user_switcher"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/keyguard_status_bar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.phone.NotificationsQuickSettingsContainer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/keyguard_bottom_area"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/status_bar_expanded_header"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.systemui.statusbar.AlphaOptimizedView</span> <span class="attr">android:id</span>=<span class="string">"@+id/qs_navbar_scrim"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.android.systemui.statusbar.phone.NotificationPanelView</span>&gt;</span><span class="comment">&lt;!-- end of sliding panel --&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/status_bar_expanded.jpg" alt="status_bar_expanded"></p><h2 id="SystemUI启动流程图"><a href="#SystemUI启动流程图" class="headerlink" title="SystemUI启动流程图"></a>SystemUI启动流程图</h2><p><img src="/images/SystemUI启动流程图1.jpg" alt="SystemUI启动流程图1"><br><img src="/images/SystemUI启动流程图2.jpg" alt="SystemUI启动流程图2"></p>]]></content>
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码 </tag>
            
            <tag> SystemUI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 泛型</title>
      <link href="/2018/09/06/Java-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2018/09/06/Java-%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>泛型, 即”参数化类型”, 是 JDK 5 中引入的新特性. 顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）.<br>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法.</p><a id="more"></a><p>举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p><p>把上面的代码稍作改动:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错</span></span><br></pre></td></tr></table></figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>泛型只是在编译阶段有效:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// D/泛型测试: 类型相同。</span></span><br></pre></td></tr></table></figure><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法:</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Container</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译期，是无法知道K和V具体是什么类型，只有在运行时才会真正根据类型来构造和分配内存。可以看一下现在Container类对于不同类型的支持情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;String, String&gt; c1 = <span class="keyword">new</span> Container&lt;String, String&gt;(<span class="string">"name"</span>, <span class="string">"findingsea"</span>);</span><br><span class="line">Container&lt;String, Integer&gt; c2 = <span class="keyword">new</span> Container&lt;String, Integer&gt;(<span class="string">"age"</span>, <span class="number">24</span>);</span><br><span class="line">Container&lt;Double, Double&gt; c3 = <span class="keyword">new</span> Container&lt;Double, Double&gt;(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br><span class="line">System.out.println(c1.getKey() + <span class="string">" : "</span> + c1.getValue());    <span class="comment">// name : findingsea</span></span><br><span class="line">System.out.println(c2.getKey() + <span class="string">" : "</span> + c2.getValue());    <span class="comment">// age : 24</span></span><br><span class="line">System.out.println(c3.getKey() + <span class="string">" : "</span> + c3.getValue());    <span class="comment">// 1.1 : 2.2</span></span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，未传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用.<br>一个基本的原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> t 传入的泛型实参</span></span><br><span class="line"><span class="comment">        * 说明：</span></span><br><span class="line"><span class="comment">        *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment">        *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment">        *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment">        *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        out(<span class="string">"findingsea"</span>);</span><br><span class="line">        out(<span class="number">123</span>);</span><br><span class="line">        out(<span class="number">11.11</span>);</span><br><span class="line">        out(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法和可变参数结合的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : args) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        out(<span class="string">"findingsea"</span>, <span class="number">123</span>, <span class="number">11.11</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种情况是非常特殊的，当泛型方法出现在泛型类中时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fruit"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"apple"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h4><p>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上.<br>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下边界"><a href="#上下边界" class="headerlink" title="上下边界"></a>上下边界</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);</span><br><span class="line">Generic&lt;Integer&gt; generic2 = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">2222</span>);</span><br><span class="line">Generic&lt;Float&gt; generic3 = <span class="keyword">new</span> Generic&lt;Float&gt;(<span class="number">2.4f</span>);</span><br><span class="line">Generic&lt;Double&gt; generic4 = <span class="keyword">new</span> Generic&lt;Double&gt;(<span class="number">2.56</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span></span><br><span class="line"><span class="comment">//showKeyValue1(generic1);</span></span><br><span class="line"></span><br><span class="line">showKeyValue1(generic2);</span><br><span class="line">showKeyValue1(generic3);</span><br><span class="line">showKeyValue1(generic4);</span><br></pre></td></tr></table></figure><p>如果我们把泛型类的定义也改一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一行代码也会报错，因为String不是Number的子类</span></span><br><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起.</p><h2 id="关于泛型数组"><a href="#关于泛型数组" class="headerlink" title="关于泛型数组"></a>关于泛型数组</h2><p>在java中是”不能创建一个确切的泛型类型的数组”的:</p><p>也就是说下面的这个例子是不可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>这样也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>Sun例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.</span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check</span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br></pre></td></tr></table></figure><p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。<br>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p><p>下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.</span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.</span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>上面有泛型的定义和赋值；当在赋值的时候，上面一节说赋值的都是为具体类型，当赋值的类型不确定的时候，我们用通配符(?)代替了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; unknownList;</span><br><span class="line">List&lt;? extends Number&gt; unknownNumberList;</span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; unknownBaseLineIntgerList;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第十三课 密封类</title>
      <link href="/2018/09/05/Kotlin-%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE-%E5%AF%86%E5%B0%81%E7%B1%BB/"/>
      <url>/2018/09/05/Kotlin-%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE-%E5%AF%86%E5%B0%81%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><p>密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。</p><p>声明一个密封类，使用 sealed 修饰类，密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。<br>但是: 扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br></pre></td></tr></table></figure><p>一个密封类是自身抽象的，它不能直接实例化并可以有抽象（abstract）成员。<br>密封类不允许有非-private 构造函数（其构造函数默认为 private）。</p><p>使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。当然，这只有当你用 when 作为表达式（使用结果）而不是作为语句时才有用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">    <span class="comment">// 不再需要 `else` 子句，因为我们已经覆盖了所有的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>举个例子，假如在 Android 中我们有一个 view，我们现在想通过 when 语句设置针对 view 进行两种操作：显示和隐藏，那么就可以这样做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">UiOp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> Show: UiOp()</span><br><span class="line">    <span class="keyword">object</span> Hide: UiOp()</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(view: <span class="type">View</span>, op: <span class="type">UiOp</span>)</span></span> = <span class="keyword">when</span> (op) &#123;</span><br><span class="line">    UiOp.Show -&gt; view.visibility = View.VISIBLE</span><br><span class="line">    UiOp.Hide -&gt; view.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上功能其实完全可以用枚举实现，但是如果我们现在想加两个操作：水平平移和纵向平移，并且还要携带一些数据，比如平移了多少距离，平移过程的动画类型等数据，用枚举显然就不太好办了，这时密封类的优势就可以发挥了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">UiOp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> Show: UiOp()</span><br><span class="line">    <span class="keyword">object</span> Hide: UiOp()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TranslateX</span></span>(<span class="keyword">val</span> px: <span class="built_in">Float</span>): UiOp()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TranslateY</span></span>(<span class="keyword">val</span> px: <span class="built_in">Float</span>): UiOp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(view: <span class="type">View</span>, op: <span class="type">UiOp</span>)</span></span> = <span class="keyword">when</span> (op) &#123;</span><br><span class="line">    UiOp.Show -&gt; view.visibility = View.VISIBLE</span><br><span class="line">    UiOp.Hide -&gt; view.visibility = View.GONE</span><br><span class="line">    <span class="keyword">is</span> UiOp.TranslateX -&gt; view.translationX = op.px <span class="comment">// 这个 when 语句分支不仅告诉 view 要水平移动，还告诉 view 需要移动多少距离，这是枚举等 Java 传统思想不容易实现的</span></span><br><span class="line">    <span class="keyword">is</span> UiOp.TranslateY -&gt; view.translationY = op.px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，TranslateX 是一个类，它可以携带多于一个的信息，比如除了告诉 view 需要水平平移之外，还可以告诉 view 平移多少像素，甚至还可以告诉 view 平移的动画类型等信息，我想这大概就是密封类出现的意义吧。</p><p>除此之外，如果 when 语句的分支不需要携带除“显示或隐藏view之外的其它信息”时（即只需要表明 when 语句分支，不需要携带额外数据时），用 object 关键字创建单例就可以了，并且此时 when 子句不需要使用 is 关键字。只有需要携带额外信息时才定义密封类的子类，而且使用了密封类就不需要使用 else 子句，每当我们多增加一个密封类的子类或单例，编译器就会在 when 语句中给出提示，可以在编译阶段就及时发现错误，这也是以往 switch-case 语句和枚举不具备的功能。</p><p>最后，我们甚至可以把这一组操作封装成一个函数，以便日后调用，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先封装一个UI操作列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ui</span></span>(<span class="keyword">val</span> uiOps: List = emptyList()) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(uiOp: <span class="type">UiOp</span>)</span></span> = Ui(uiOps + uiOp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一组操作</span></span><br><span class="line"><span class="keyword">val</span> ui = Ui() +</span><br><span class="line">        UiOp.Show +</span><br><span class="line">        UiOp.TranslateX(<span class="number">20</span>f) +</span><br><span class="line">        UiOp.TranslateY(<span class="number">40</span>f) +</span><br><span class="line">        UiOp.Hide</span><br><span class="line"><span class="comment">// 定义调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">(view: <span class="type">View</span>, ui: <span class="type">Ui</span>)</span></span> &#123;</span><br><span class="line">    ui.uiOps.forEach &#123; execute(view, it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(view, ui) <span class="comment">// 最终调用</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> class </tag>
            
            <tag> sealed </tag>
            
            <tag> 密封类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POJO</title>
      <link href="/2018/09/05/POJO/"/>
      <url>/2018/09/05/POJO/</url>
      <content type="html"><![CDATA[<h1 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h1><p>Plain Ordinary Java Object<br>简单地 Java 对象, 实际上就是普通的 JavaBeans, 是为了避免和 EJB 混淆所创造的简称.</p><a id="more"></a><p>JavaBean 是一种JAVA语言写成的可重用组件。它的方法命名，构造及行为必须符合特定的约定：</p><ul><li>这个类必须有一个公共的缺省构造函数</li><li>这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范</li><li>这个类应是可序列化的</li></ul><p>因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO。</p><p>简而言之，当一个Pojo可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean。</p><p>简单理解:</p><p>POJO 是 DO/DTO/BO/VO 的统称, 但禁止被命名成 xxxPOJO 而已.</p><ul><li>数据对象: xxxDO</li><li>数据传输对象: xxxDTO</li><li>展示对象: xxxVO</li><li>业务对象: xxxBO</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> pojo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>exports 与 module.exports</title>
      <link href="/2018/09/04/exports-%E4%B8%8E-module-exports/"/>
      <url>/2018/09/04/exports-%E4%B8%8E-module-exports/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面有总结 es6 中的 import 和 export, 顺带着一起总结下 node 中的 exports 和 module.exports.</p><a id="more"></a><h1 id="exports-和-module-exports"><a href="#exports-和-module-exports" class="headerlink" title="exports 和 module.exports"></a>exports 和 module.exports</h1><p>在一个node执行一个文件时，会给这个文件内生成一个 exports和module对象，<br>而module又有一个exports属性。他们之间的关系如下图，都指向一块{}内存区域.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/exports与module_exports.png" alt="exports与module_exports"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//utils.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports); <span class="comment">//能打印出结果为：&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(exports); <span class="comment">//能打印出结果为：&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">exports.a = <span class="number">200</span>; <span class="comment">//这里辛苦劳作帮 module.exports 的内容给改成 &#123;a : 200&#125;</span></span><br><span class="line"></span><br><span class="line">exports = <span class="string">'指向其他内存区'</span>; <span class="comment">//这里把exports的指向指走</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'/utils'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 打印为 &#123;a : 200&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">test.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="number">1</span>&#125;;  <span class="comment">// 类比 module.exports</span></span><br><span class="line"><span class="keyword">var</span> b = a;          <span class="comment">// 类比 exports</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line">b.name = <span class="number">2</span>;         <span class="comment">// 将 a 的值改了</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">name</span>: <span class="number">3</span>&#125;;  <span class="comment">// b 重新赋值了, 但是 a 不变</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line">运行 test.js 结果为：</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>总结:</p><ul><li>module.exports 初始值为一个空对象 {}</li><li>exports 是指向的 module.exports 的引用</li><li>require() 返回的是 module.exports 而不是 exports</li></ul><p>所以，为了避免糊涂，尽量都用 module.exports 导出，然后用require导入.</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> exports </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>import 与 export</title>
      <link href="/2018/09/04/import-%E4%B8%8E-export/"/>
      <url>/2018/09/04/import-%E4%B8%8E-export/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在新的项目组的代码中, 看到了 require, 再考虑到 es6 中的 import 和 export, 有点方. 所以, 想在这里系统的总结下, 也便于给小伙伴们学习下.</p><a id="more"></a><h1 id="import"><a href="#import" class="headerlink" title="import"></a>import</h1><p>import命令用于输入其他模块提供的功能.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"module-name"</span>;</span><br></pre></td></tr></table></figure><p>defaultExport: 将引用模块默认导出的名称。</p><p>module-name: 要导入的模块。这通常是包含模块的.js文件的相对或绝对路径名，不包括.js扩展名。某些打包工具可以允许或要求使用该扩展；检查你的运行环境。只允许单引号和双引号的字符串。</p><p>name: 引用时将用作一种命名空间的模块对象的名称。</p><p>export, exportN: 要导入的导出名称。</p><p>alias, aliasN: 将引用指定的导入的名称。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="导入整个模块的内容"><a href="#导入整个模块的内容" class="headerlink" title="导入整个模块的内容"></a>导入整个模块的内容</h3><p>这将myModule插入当前作用域，其中包含来自位于/modules/my-module.js文件中导出的所有模块:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">'/modules/my-module.js'</span>;</span><br></pre></td></tr></table></figure><p>在这里，访问导出意味着使用模块名称（在这种情况下为“myModule”）作为命名空间。例如，如果上面导入的模块包含一个doAllTheAmazingThings()，你可以这样调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myModule.doAllTheAmazingThings();</span><br></pre></td></tr></table></figure><h3 id="导入单个导出"><a href="#导入单个导出" class="headerlink" title="导入单个导出"></a>导入单个导出</h3><p>给定一个名为myExport的对象或值，它已经从模块my-module导出（因为整个模块被导出）或显式地导出（使用export语句），将myExport插入当前作用域:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;myExport&#125; <span class="keyword">from</span> <span class="string">'/modules/my-module.js'</span>;</span><br></pre></td></tr></table></figure><h3 id="导入多个导出"><a href="#导入多个导出" class="headerlink" title="导入多个导出"></a>导入多个导出</h3><p>将foo和bar插入当前作用域:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'/modules/my-module.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br></pre></td></tr></table></figure><p>注: CommonJS require 的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 2 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>而 import 实质是从fs模块加载 2 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p><h3 id="导入带有别名的导出"><a href="#导入带有别名的导出" class="headerlink" title="导入带有别名的导出"></a>导入带有别名的导出</h3><p>导入时可以重命名导出。例如，将shortName插入当前作用域:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reallyReallyLongModuleExportName <span class="keyword">as</span> shortName&#125; <span class="keyword">from</span> <span class="string">'/modules/my-module.js'</span>;</span><br></pre></td></tr></table></figure><h3 id="导入默认值"><a href="#导入默认值" class="headerlink" title="导入默认值"></a>导入默认值</h3><p>在 default export（无论是对象，函数，类等）有效时可用。然后可以使用import语句来导入这样的默认值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myDefault <span class="keyword">from</span> <span class="string">"my-module"</span>;</span><br></pre></td></tr></table></figure><p>也可以同时将default语法与上述用法（命名空间导入或命名导入）一起使用。在这种情况下，default导入必须首先声明:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myDefault, * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">"my-module"</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> myDefault, &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">"my-module"</span>;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="只读接口"><a href="#只读接口" class="headerlink" title="只读接口"></a>只读接口</h3><p>import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line"></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : 'a' is read-only;</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line"></span><br><span class="line">a.foo = <span class="string">'hello'</span>; <span class="comment">// 合法操作</span></span><br></pre></td></tr></table></figure><p>注: 上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。</p><h3 id="模块文件的位置"><a href="#模块文件的位置" class="headerlink" title="模块文件的位置"></a>模块文件的位置</h3><p>后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置.</p><h3 id="提升效果"><a href="#提升效果" class="headerlink" title="提升效果"></a>提升效果</h3><p>import 命令具有提升效果，会提升到整个模块的头部，首先执行:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>原因是: import 命令是编译阶段执行的，在代码运行之前。</p><h3 id="不能使用表达式和变量"><a href="#不能使用表达式和变量" class="headerlink" title="不能使用表达式和变量"></a>不能使用表达式和变量</h3><p>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module1'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Singleton-模式"><a href="#Singleton-模式" class="headerlink" title="Singleton 模式"></a>Singleton 模式</h3><p>import语句是 Singleton 模式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><h1 id="export"><a href="#export" class="headerlink" title="export"></a>export</h1><p>export命令用于规定模块的对外接口.</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><h3 id="导出变量"><a href="#导出变量" class="headerlink" title="导出变量"></a>导出变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure><p>等同于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>注: 应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><h3 id="导出函数"><a href="#导出函数" class="headerlink" title="导出函数"></a>导出函数</h3><p>export命令除了输出变量，还可以输出函数或类（class）:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function multiply(x, y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="导出重命名的变量或函数"><a href="#导出重命名的变量或函数" class="headerlink" title="导出重命名的变量或函数"></a>导出重命名的变量或函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。</p><h2 id="导出注意"><a href="#导出注意" class="headerlink" title="导出注意"></a>导出注意</h2><h3 id="一一对应关系"><a href="#一一对应关系" class="headerlink" title="一一对应关系"></a>一一对应关系</h3><p>export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br></pre></td></tr></table></figure><p>上面两种写法都会报错，因为没有提供对外的接口:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure><p>它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p><h3 id="处于模块顶级"><a href="#处于模块顶级" class="headerlink" title="处于模块顶级"></a>处于模块顶级</h3><p>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'bar'</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。<br>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line"></span><br><span class="line">customName(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><h3 id="对比下-export-和-export-default"><a href="#对比下-export-和-export-default" class="headerlink" title="对比下 export 和 export default"></a>对比下 export 和 export default</h3><p>export default命令的本质是将后面的值，赋给default变量.<br>export 是指定对外的接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure><h1 id="export-和-import-的复合使用"><a href="#export-和-import-的复合使用" class="headerlink" title="export 和 import 的复合使用"></a>export 和 import 的复合使用</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为(但不同)</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure><p>注: export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体输出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名接口改为默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名接口改为默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口也可以改名为具名接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br></pre></td></tr></table></figure><h2 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h2><p>const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">'http://my.couchdbserver.local:5984'</span>,</span><br><span class="line">  admin_username: <span class="string">'admin'</span>,</span><br><span class="line">  admin_password: <span class="string">'admin password'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">'root'</span>, <span class="string">'admin'</span>, <span class="string">'staff'</span>, <span class="string">'ceo'</span>, <span class="string">'chief'</span>, <span class="string">'moderator'</span>];</span><br></pre></td></tr></table></figure><p>然后，将这些文件输出的常量，合并在index.js里面:</p><p>// constants/index.js<br>export {db} from ‘./db’;<br>export {users} from ‘./users’;</p><p>使用的时候，直接加载index.js就可以了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">'./constants/index'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> import </tag>
            
            <tag> js </tag>
            
            <tag> export </tag>
            
            <tag> export default </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第十二课 -- 数据类</title>
      <link href="/2018/09/03/Kotlin-%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE-%E6%95%B0%E6%8D%AE%E7%B1%BB/"/>
      <url>/2018/09/03/Kotlin-%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE-%E6%95%B0%E6%8D%AE%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 data：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>编译器自动从主构造函数中声明的所有属性导出以下成员：</p><ul><li>equals()/hashCode() 对</li><li>toString() 格式是 “User(name=John, age=42)”</li><li>componentN() 函数 按声明顺序对应于所有属性</li><li>copy() 函数</li></ul><p>为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：</p><ul><li>主构造函数需要至少有一个参数</li><li>主构造函数的所有参数需要标记为 val 或 var</li><li>数据类不能是抽象、开放、密封或者内部的</li></ul><p>成员生成遵循关于成员继承的这些规则：</p><ul><li>如果在数据类体中有显式实现 equals()、 hashCode() 或者 toString()，或者这些函数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数</li><li>如果超类型具有 open 的 componentN() 函数并且返回兼容的类型， 那么会为数据类生成相应的函数，并覆盖超类的实现。如果超类型的这些函数由于签名不兼容或者是 final 而导致无法覆盖，那么会报错</li><li>从一个已具 copy(……) 函数且签名匹配的类型派生一个数据类在 Kotlin 1.2 中已弃用，并且会在 Kotlin 1.3 中禁用。</li><li>不允许为 componentN() 以及 copy() 函数提供显式实现。</li></ul><p>在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String = <span class="string">""</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="在类体中声明的属性"><a href="#在类体中声明的属性" class="headerlink" title="在类体中声明的属性"></a>在类体中声明的属性</h2><p>对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。如需在生成的实现中排出一个属性，请将其声明在类体中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 toString()、 equals()、 hashCode() 以及 copy() 的实现中只会用到 name 属性，并且只有一个 component 函数 component1()。虽然两个 Person 对象可以有不同的年龄，但它们会视为相等:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person1 = Person(<span class="string">"John"</span>)</span><br><span class="line">    <span class="keyword">val</span> person2 = Person(<span class="string">"John"</span>)</span><br><span class="line">    person1.age = <span class="number">10</span></span><br><span class="line">    person2.age = <span class="number">20</span></span><br><span class="line">    println(<span class="string">"person1 == person2: <span class="subst">$&#123;person1 == person2&#125;</span>"</span>)        <span class="comment">// person1 == person2: true</span></span><br><span class="line">    println(<span class="string">"person1 with age <span class="subst">$&#123;person1.age&#125;</span>: <span class="subst">$&#123;person1&#125;</span>"</span>)      <span class="comment">// person1 with age 10: Person(name=John)</span></span><br><span class="line">    println(<span class="string">"person2 with age <span class="subst">$&#123;person2.age&#125;</span>: <span class="subst">$&#123;person2&#125;</span>"</span>)      <span class="comment">// person2 with age 20: Person(name=John)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。对于上文的 User 类，其实现会类似下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, age: <span class="type">Int</span> = this.age)</span></span> = User(name, age)</span><br></pre></td></tr></table></figure><p>我们可以这样写:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jack = User(name = <span class="string">"Jack"</span>, age = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="数据类与解构声明"><a href="#数据类与解构声明" class="headerlink" title="数据类与解构声明"></a>数据类与解构声明</h2><p>为数据类生成的 Component 函数 使它们可在解构声明中使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jane = User(<span class="string">"Jane"</span>, <span class="number">35</span>)</span><br><span class="line"><span class="keyword">val</span> (name, age) = jane</span><br><span class="line">println(<span class="string">"<span class="variable">$name</span>, <span class="variable">$age</span> years of age"</span>) <span class="comment">// 输出 "Jane, 35 years of age"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> class </tag>
            
            <tag> 数据类 </tag>
            
            <tag> copy </tag>
            
            <tag> componentN </tag>
            
            <tag> data </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第十一课 -- 单例与伴生对象</title>
      <link href="/2018/08/30/Kotlin-%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE-%E5%8D%95%E4%BE%8B%E4%B8%8E%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/08/30/Kotlin-%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE-%E5%8D%95%E4%BE%8B%E4%B8%8E%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><p>Kotlin 中没有 static 关键字, 如果需要实现单例, 可以使用关键字 object 声明一个对象, 对象的构造器不能提供构造参数.<br>在第一次使用的时候会被初始化, 可用于提供常量或共享不可变对象.</p><a id="more"></a><h2 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">DataProvider</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> allDataProviders: Collection&lt;DataProvider&gt;</span><br><span class="line">        <span class="keyword">get</span>() = <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如需引用该对象，我们直接使用其名称即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataProviderManager.registerDataProvider(……)</span><br></pre></td></tr></table></figure><p>这些对象可以有超类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DefaultListener : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 对象声明不能在局部作用域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中.</p><h1 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h1><p>类内部的对象声明可以用 companion 关键字标记：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该伴生对象的成员可通过只使用类名作为限定符来调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instance = MyClass.create()</span><br></pre></td></tr></table></figure><p>可以省略伴生对象的名称，在这种情况下将使用名称 Companion：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = MyClass.Companion</span><br></pre></td></tr></table></figure><p>注: 即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Factory&lt;MyClass&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        const  <span class="keyword">val</span> s= <span class="string">""</span></span><br><span class="line">        <span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = print(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据块中的属性或者方法可以使用类.成员的方式调用（调用方式和static成员一致），但是他们在运行时依然是实体的实例成员:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: Singleton2&#123;</span><br><span class="line">            <span class="keyword">return</span> Inner2.instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span>  Inner2&#123;</span><br><span class="line">        <span class="keyword">val</span> instance: Singleton2    = Singleton2()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上: 我们使用伴生对象可以更好的和单例结合，这样在调用单例的时候可以在我们想要获得单例实例的时候再出初始化单例，保证了线程安全.</p>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 伴生对象 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第十课 -- 可见性修饰符</title>
      <link href="/2018/08/30/Kotlin-%E7%AC%AC%E5%8D%81%E8%AF%BE-%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2018/08/30/Kotlin-%E7%AC%AC%E5%8D%81%E8%AF%BE-%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h1><p>类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有可见性修饰符（getter 总是与属性有着相同的可见性）.<br>在 Kotlin 中有以下这四个可见性修饰符:</p><ul><li>public</li><li>internal</li><li>protected</li><li>private</li></ul><p>如果没有显式指定修饰符的话，默认可见性是 public.</p><a id="more"></a><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>函数、属性和类、对象和接口可以在顶层声明，即直接在包内：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：example.kt</span></span><br><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见</li><li>如果你声明为 internal，它会在相同模块内随处可见</li><li>如果你声明为 private，它只会在声明它的文件内可见</li><li>protected 不适用于顶层声明</li></ul><p>注: 要使用另一包中可见的顶层声明，仍需将其导入进来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：example.kt</span></span><br><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; …… &#125; <span class="comment">// 在 example.kt 内可见</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">5</span> <span class="comment">// 该属性随处可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">set</span>         <span class="comment">// setter 只在 example.kt 内可见</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> baz = <span class="number">6</span>    <span class="comment">// 相同模块内可见</span></span><br></pre></td></tr></table></figure><h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><p>对于类内部声明的成员：</p><ul><li>public —— 能见到类声明的任何客户端都可见其 public 成员</li><li>internal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员</li><li>protected—— 和 private一样 + 在子类中可见</li><li>private 意味着只在这个类内部（包含其所有成员）可见</li></ul><p>注: 对于Java用户：Kotlin 中外部类不能访问内部类的 private 成员.</p><p>如果你覆盖一个 protected 成员并且没有显式指定其可见性，该成员还会是 protected 可见性.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="keyword">val</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> d = <span class="number">4</span>  <span class="comment">// 默认 public</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> e: <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> : <span class="type">Outer</span></span>() &#123;</span><br><span class="line">    <span class="comment">// a 不可见</span></span><br><span class="line">    <span class="comment">// b、c、d 可见</span></span><br><span class="line">    <span class="comment">// Nested 和 e 可见</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> b = <span class="number">5</span>   <span class="comment">// “b”为 protected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unrelated</span></span>(o: Outer) &#123;</span><br><span class="line">    <span class="comment">// o.a、o.b 不可见</span></span><br><span class="line">    <span class="comment">// o.c 和 o.d 可见（相同模块）</span></span><br><span class="line">    <span class="comment">// Outer.Nested 不可见，Nested::e 也不可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>要指定一个类的的主构造函数的可见性，使用以下语法（注意你需要添加一个显式 constructor 关键字）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(a: <span class="built_in">Int</span>) &#123; …… &#125;</span><br></pre></td></tr></table></figure><p>这里的构造函数是私有的。默认情况下，所有构造函数都是 public，这实际上等于类可见的地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见).</p><h2 id="局部声明"><a href="#局部声明" class="headerlink" title="局部声明"></a>局部声明</h2><p>局部变量、函数和类不能有可见性修饰符。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件：</p><ul><li>一个 IntelliJ IDEA 模块</li><li>一个 Maven 项目</li><li>一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）</li><li>一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件</li></ul>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 模块 </tag>
            
            <tag> public </tag>
            
            <tag> internal </tag>
            
            <tag> protected </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第九课 -- 扩展</title>
      <link href="/2018/08/29/Kotlin-%E7%AC%AC%E4%B9%9D%E8%AF%BE-%E6%89%A9%E5%B1%95/"/>
      <url>/2018/08/29/Kotlin-%E7%AC%AC%E4%B9%9D%E8%AF%BE-%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式.<br>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响.</p><a id="more"></a><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> receiverType.<span class="title">functionName</span><span class="params">(params)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>receiverType：表示函数的接收者，也就是函数扩展的对象</li><li>functionName：扩展函数的名称</li><li>params：扩展函数的参数，可以为NULL</li></ul><p>MutableList<int> 添加一个swap 函数:</int></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1] <span class="comment">// “this”对应该列表</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 这个 this 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象）.</p><p>使用泛型:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1] <span class="comment">// “this”对应该列表</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 为了在接收者类型表达式中使用泛型，我们要在函数名前声明泛型参数.</p><h3 id="扩展是静态的"><a href="#扩展是静态的" class="headerlink" title="扩展是静态的"></a>扩展是静态的</h3><p>扩展不能真正的修改他们所扩展的类.通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数.<br>在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">    println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFoo(D())   <span class="comment">// "c"</span></span><br></pre></td></tr></table></figure><p>这个例子会输出 “c”，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类.</p><p>如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字并且都适用给定的参数，这种情况总是取成员函数。 例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"member"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"extension"</span>) &#125;    </span><br><span class="line"></span><br><span class="line">C().foo()     <span class="comment">// “member”</span></span><br></pre></td></tr></table></figure><p>当然，扩展函数重载同样名字但不同签名成员函数也完全可以：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"member"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123; println(<span class="string">"extension"</span>) &#125;</span><br><span class="line"></span><br><span class="line">C().foo(<span class="number">1</span>)      <span class="comment">// "extension"</span></span><br></pre></td></tr></table></figure><h3 id="可空接收者"><a href="#可空接收者" class="headerlink" title="可空接收者"></a>可空接收者</h3><p>可以为可空的接收者类型定义扩展.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    <span class="comment">// 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()</span></span><br><span class="line">    <span class="comment">// 解析为 Any 类的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><p>与函数类似，Kotlin 支持扩展属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = size - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中.初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Foo.bar = <span class="number">1</span> <span class="comment">// 错误：扩展属性不能有初始化器</span></span><br></pre></td></tr></table></figure><p>注: 扩展属性只能被声明为 val.</p><h2 id="伴生对象的扩展"><a href="#伴生对象的扩展" class="headerlink" title="伴生对象的扩展"></a>伴生对象的扩展</h2><p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数与属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;  <span class="comment">// 将被称为 "Companion"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"伴随对象的扩展函数"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> MyClass.Companion.no: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"no:<span class="subst">$&#123;MyClass.no&#125;</span>"</span>)</span><br><span class="line">    MyClass.foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展的作用域"><a href="#扩展的作用域" class="headerlink" title="扩展的作用域"></a>扩展的作用域</h2><p>大多数时候我们在顶层定义扩展，即直接在包里：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Baz.<span class="title">goo</span><span class="params">()</span></span> &#123; …… &#125;</span><br></pre></td></tr></table></figure><p>要使用所定义包之外的一个扩展，我们需要在调用方导入它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.usage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo.bar.goo <span class="comment">// 导入所有名为“goo”的扩展</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> foo.bar.*   <span class="comment">// 从“foo.bar”导入一切</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">usage</span><span class="params">(baz: <span class="type">Baz</span>)</span></span> &#123;</span><br><span class="line">    baz.goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展声明为成员"><a href="#扩展声明为成员" class="headerlink" title="扩展声明为成员"></a>扩展声明为成员</h2><p>在一个类内部你可以为另一个类声明扩展。<br>在这个扩展中，有个多个隐含的接受者 —— 其中的对象成员可以无需通过限定符访问，扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cclass D &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"D bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123; println(<span class="string">"C baz"</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar()   <span class="comment">// 调用 D.bar</span></span><br><span class="line">        baz()   <span class="comment">// 调用 C.baz</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c: C = C()</span><br><span class="line">    <span class="keyword">val</span> d: D = D()</span><br><span class="line">    c.caller(d)     <span class="comment">// "D bar"  "C baz"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中,在 C 类内创建了 D 类的扩展。此时，C 被成为分发接受者，而 D 为扩展接受者。从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。</p><p>假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"D bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"C bar"</span>) &#125;  <span class="comment">// 与 D 类 的 bar 同名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar()         <span class="comment">// 调用 D.bar()，扩展接收者优先</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@C</span>.bar()  <span class="comment">// 调用 C.bar()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c: C = C()</span><br><span class="line">    <span class="keyword">val</span> d: D = D()</span><br><span class="line">    c.caller(d)        <span class="comment">//  "D bar"  "C bar"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以成员的形式定义的扩展函数, 可以声明为 open , 而且可以在子类中覆盖. 也就是说, 在这类扩展函数的派 发过程中, 针对分发接受者是虚拟的(virtual), 但针对扩展接受者仍然是静态的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> : <span class="type">D</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> : <span class="type">C</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    C().caller(D())   <span class="comment">// 输出 "D.foo in C"</span></span><br><span class="line">    C1().caller(D())  <span class="comment">// 输出 "D.foo in C1" —— 分发接收者虚拟解析</span></span><br><span class="line">    C().caller(D1())  <span class="comment">// 输出 "D.foo in C" —— 扩展接收者静态解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展的意义"><a href="#扩展的意义" class="headerlink" title="扩展的意义"></a>扩展的意义</h2><p>在Java中，我们将类命名为“*Utils”：FileUtils、StringUtils 等，著名的 java.util.Collections 也属于同一种命名方式。 关于这些 Utils-类的不愉快的部分是代码写成这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">Collections.swap(list, Collections.binarySearch(list,</span><br><span class="line">    Collections.max(otherList)),</span><br><span class="line">    Collections.max(list));</span><br></pre></td></tr></table></figure><p>这些类名总是碍手碍脚的，我们可以通过静态导入达到这样效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">swap(list, binarySearch(list, max(otherList)), max(list));</span><br></pre></td></tr></table></figure><p>这会变得好一点，但是我们并没有从 IDE 强大的自动补全功能中得到帮助。如果能这样就更好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">list.swap(list.binarySearch(otherList.max()), list.max());</span><br></pre></td></tr></table></figure><p>但是我们不希望在 List 类内实现这些所有可能的方法，对吧？这时候扩展将会帮助我们.</p>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 伴生对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第八课 -- 接口</title>
      <link href="/2018/08/28/Kotlin-%E7%AC%AC%E5%85%AB%E8%AF%BE-%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/08/28/Kotlin-%E7%AC%AC%E5%85%AB%E8%AF%BE-%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现.<br>它可以有属性但必须声明为抽象或提供访问器实现.<br>接口不会保存属性值，实现接口时，必须重写属性.<br>使用关键字 interface 来定义接口.</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 可选的方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>一个类或者对象可以实现一个或多个接口:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h2><p>可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> prop: <span class="built_in">Int</span> <span class="comment">// 抽象的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> propertyWithImplementation: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        print(prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> prop: <span class="built_in">Int</span> = <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nterface Named &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> : <span class="type">Named &#123;</span></span></span><br><span class="line">    <span class="keyword">val</span> firstName: String</span><br><span class="line">    <span class="keyword">val</span> lastName: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name: String <span class="keyword">get</span>() = <span class="string">"<span class="variable">$firstName</span> <span class="variable">$lastName</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>(</span><br><span class="line">    <span class="comment">// 不必实现“name”</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> firstName: String,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> lastName: String,</span><br><span class="line">    <span class="keyword">val</span> position: Position</span><br><span class="line">) : Person</span><br></pre></td></tr></table></figure><h2 id="解决覆盖冲突"><a href="#解决覆盖冲突" class="headerlink" title="解决覆盖冲突"></a>解决覆盖冲突</h2><p>实现多个接口时，可能会遇到同一方法继承多个实现的问题:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">A</span>, <span class="type">B &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.foo()</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.foo()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> interface </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第七课 -- 属性</title>
      <link href="/2018/08/27/Kotlin-%E7%AC%AC%E4%B8%83%E8%AF%BE-%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/08/27/Kotlin-%E7%AC%AC%E4%B8%83%E8%AF%BE-%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="var-和-val"><a href="#var-和-val" class="headerlink" title="var 和 val"></a>var 和 val</h2><p>用关键字 var 声明的属性为可变属性, 用关键字 val 声明的属性为只读属性.</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用一个属性，只要用名称引用它即可:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyAddress</span><span class="params">(address: <span class="type">Address</span>)</span></span>: Address &#123;</span><br><span class="line">    <span class="keyword">val</span> result = Address() <span class="comment">// Kotlin 中没有“new”关键字</span></span><br><span class="line">    result.name = address.name <span class="comment">// 将调用访问器</span></span><br><span class="line">    result.street = address.street</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Getter-和-Setter"><a href="#Getter-和-Setter" class="headerlink" title="Getter 和 Setter"></a>Getter 和 Setter</h2><p>声明一个属性的完整语法是:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure><p>其初始器（initializer）、getter 和 setter 都是可选的.<br>属性类型如果可以从初始器 （或者从其 getter 返回值，如下文所示）中推断出来，也可以省略:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allByDefault: <span class="built_in">Int</span>? <span class="comment">// 错误：需要显式初始化器，隐含默认 getter 和 setter</span></span><br><span class="line"><span class="keyword">var</span> initialized = <span class="number">1</span> <span class="comment">// 类型 Int、默认 getter 和 setter</span></span><br></pre></td></tr></table></figure><p>我们可以编写自定义的访问器:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringRepresentation: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.toString()</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        setDataFromString(value) <span class="comment">// 解析字符串并赋值给其他属性</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注: setter 参数的默认名称是 value，也可以选择一个不同的名称</p><p>自 Kotlin 1.1 起，如果可以从 getter 推断出属性类型，则可以省略它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span>  <span class="comment">// 具有类型 Boolean</span></span><br></pre></td></tr></table></figure><p>如果需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现， 你可以定义访问器而不定义其实现:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setterVisibility: String = <span class="string">"abc"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">// 此 setter 是私有的并且有默认实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setterWithAnnotation: Any? = <span class="literal">null</span></span><br><span class="line">    <span class="meta">@Inject</span> <span class="keyword">set</span> <span class="comment">// 用 Inject 注解此 setter</span></span><br></pre></td></tr></table></figure><h2 id="只读属性和可变属性的区别"><a href="#只读属性和可变属性的区别" class="headerlink" title="只读属性和可变属性的区别"></a>只读属性和可变属性的区别</h2><ol><li>只读属性的用 val开始代替var</li><li>只读属性不允许 setter</li></ol><h2 id="Field-关键字"><a href="#Field-关键字" class="headerlink" title="Field 关键字"></a>Field 关键字</h2><p>在 Kotlin 中，任何时候当你写出“一个变量后边加等于号”这种形式的时候，比如我们定义 var no: Int 变量，当你写出 no = … 这种形式的时候，这个等于号都会被编译器翻译成调用 setter 方法；而同样，在任何位置引用变量时，只要出现 no 变量的地方都会被编译器翻译成 getter 方法。那么问题就来了，当你在 setter 方法内部写出 no = … 时，相当于在 setter 方法中调用 setter 方法，形成递归，进而形成死循环，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> no: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">get</span>() = field                <span class="comment">// 后端变量</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;       <span class="comment">// 如果传入的值小于 10 返回该值</span></span><br><span class="line">            field = value</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            field = <span class="number">-1</span>         <span class="comment">// 如果传入的值大于等于 10 返回 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码按以上这种写法是正确的，因为使用了 field 关键字，但是如果不用 field 关键字会怎么样呢？例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> no: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">get</span>() = no</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;       <span class="comment">// 如果传入的值小于 10 返回该值</span></span><br><span class="line">            no = value</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            no = <span class="number">-1</span>         <span class="comment">// 如果传入的值大于等于 10 返回 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意这里我们使用的 Java 的思维写了 getter 和 setter 方法，那么这时，如果将这段代码翻译成 Java 代码会是怎么样呢？如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> no = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNo();<span class="comment">// Kotlin中的get() = no语句中出来了变量no，直接被编译器理解成“调用getter方法”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        setNo(value);<span class="comment">// Kotlin中出现“no =”这样的字样，直接被编译器理解成“这里要调用setter方法”</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setNo(-<span class="number">1</span>);<span class="comment">// 在setter方法中调用setter方法，这是不正确的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成 Java 代码之后就很直观了，在 getter 方法和 setter 方法中都形成了递归调用，显然是不正确的，最终程序会出现内存溢出而异常终止。</p><p>注: field 标识符只能用在属性的访问器内.</p><h2 id="延迟初始化属性与变量"><a href="#延迟初始化属性与变量" class="headerlink" title="延迟初始化属性与变量"></a>延迟初始化属性与变量</h2><p>一般地，属性声明为非空类型必须在构造函数中初始化。 然而，这经常不方便。例如：属性可以通过依赖注入来初始化， 或者在单元测试的 setup 方法中初始化。 这种情况下，你不能在构造函数内提供一个非空初始器。 但你仍然想在类体中引用该属性时避免空检查。<br>为处理这种情况，可以用 lateinit 修饰符标记该属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SetUp</span> <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject = TestSubject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.method()  <span class="comment">// 直接解引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注:</p><ul><li>该修饰符只能用于在类体中的属性（不是在主构造函数中声明的 var 属性，并且仅当该属性没有自定义 getter 或 setter 时），而自 Kotlin 1.2 起，也用于顶层属性与局部变量。该属性或变量必须为非空类型，并且不能是原生类型.</li><li>在初始化前访问一个 lateinit 属性会抛出一个特定异常，该异常明确标识该属性被访问及它没有初始化的事实。</li></ul><h3 id="检测一个-lateinit-var-是否已初始化"><a href="#检测一个-lateinit-var-是否已初始化" class="headerlink" title="检测一个 lateinit var 是否已初始化"></a>检测一个 lateinit var 是否已初始化</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo::bar.isInitialized) &#123;</span><br><span class="line">    println(foo.bar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>Kotlin 中的:<br>    val num = 6<br>等价于 Java 中的:<br>    public final int num = 6</p><p>但是, Kotlin 中用 val 修饰还不是常量, 只能是不能修改的变量.而常量的定义, 需要在关键字 val 前面加上关键字 const:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">val</span> NUM = <span class="number">6</span></span><br></pre></td></tr></table></figure><p>注: const 只能修饰 val, 不能修饰 var.</p><h3 id="声明常量的三种方式"><a href="#声明常量的三种方式" class="headerlink" title="声明常量的三种方式"></a>声明常量的三种方式</h3><ul><li>在顶层声明</li><li>在 object 修饰的类中声明, 在 Kotlin 中称为对象声明, 相当于 Java 中一种形式的单例类</li><li>在伴生对象中声明</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 顶层声明</span></span><br><span class="line">const <span class="keyword">val</span> NUM_A : String = <span class="string">"顶层声明"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在object修饰的类中</span></span><br><span class="line"><span class="keyword">object</span> TestConst&#123;</span><br><span class="line">    const <span class="keyword">val</span> NUM_B = <span class="string">"object修饰的类中"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 伴生对象中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        const <span class="keyword">val</span> NUM_C = <span class="string">"伴生对象中声明"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"NUM_A =&gt; <span class="variable">$NUM_A</span>"</span>)</span><br><span class="line">    println(<span class="string">"NUM_B =&gt; <span class="subst">$&#123;TestConst.NUM_B&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"NUM_C =&gt; <span class="subst">$&#123;TestClass.NUM_C&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> property </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第六课 -- 类与继承</title>
      <link href="/2018/08/26/Kotlin-%E7%AC%AC%E5%85%AD%E8%AF%BE-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/08/26/Kotlin-%E7%AC%AC%E5%85%AD%E8%AF%BE-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>Kotlin 中使用关键字 class 声明类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoice</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数.</p><h3 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h3><p>主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中:</p><p>在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitOrderDemo</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> firstProperty = <span class="string">"First property: <span class="variable">$name</span>"</span>.also(::println)</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"First initializer block that prints <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> secondProperty = <span class="string">"Second property: <span class="subst">$&#123;name.length&#125;</span>"</span>.also(::println)</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"Second initializer block that prints <span class="subst">$&#123;name.length&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123; …… &#125;</span><br></pre></td></tr></table></figure><p>注: 与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）.</p><p>如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">public</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(name: String) &#123; …… &#125;</span><br></pre></td></tr></table></figure><h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p>前缀有 constructor的次构造函数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parent: Person) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, parent: Person) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constructors</span> </span>&#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"Init block"</span>)   <span class="comment">// 先执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(i: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        println(<span class="string">"Constructor"</span>)  <span class="comment">// 后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public.<br>如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontCreateMe</span> <span class="keyword">private</span> <span class="keyword">constructor</span> </span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>注: 在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> customerName: String = <span class="string">""</span>)</span><br></pre></td></tr></table></figure><h2 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h2><p>要创建一个类的实例，我们就像普通函数一样调用构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> invoice = Invoice()</span><br><span class="line"><span class="keyword">val</span> customer = Customer(<span class="string">"Joe Smith"</span>)</span><br></pre></td></tr></table></figure><p>注: Kotlin 并没有 new 关键字.</p><h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><ul><li>构造函数与初始化块</li><li>函数</li><li>属性</li><li>嵌套类与内部类</li><li>对象声明</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>类以及其中的某些成员可以声明为 abstract,  抽象成员在本类中可以不用实现.<br>我们可以用一个抽象成员覆盖一个非抽象的开放成员:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>我们可以把类嵌套在其他类中:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;                  <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;             <span class="comment">// 嵌套类</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Outer.Nested().foo() <span class="comment">// 调用格式：外部类.嵌套类.嵌套类方法/属性</span></span><br><span class="line">    println(demo)    <span class="comment">// == 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类使用 inner 关键字来表示。<br>内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">"成员属性"</span></span><br><span class="line">    <span class="comment">/**嵌套内部类**/</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">// 访问外部类成员</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">innerTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> o = <span class="keyword">this</span><span class="symbol">@Outer</span> <span class="comment">//获取外部类的成员变量</span></span><br><span class="line">            println(<span class="string">"内部类可以引用外部类的成员，例如："</span> + o.v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Outer().Inner().foo()</span><br><span class="line">    println(demo) <span class="comment">//   1</span></span><br><span class="line">    <span class="keyword">val</span> demo2 = Outer().Inner().innerTest()   </span><br><span class="line">    println(demo2)   <span class="comment">// 内部类可以引用外部类的成员，例如：成员属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 为了消除歧义，要访问来自外部作用域的 this，我们使用this@label，其中 @label 是一个 代指 this 来源的标签。</p><h3 id="嵌套类和内部类在使用时的区别"><a href="#嵌套类和内部类在使用时的区别" class="headerlink" title="嵌套类和内部类在使用时的区别"></a>嵌套类和内部类在使用时的区别</h3><h4 id="创建对象的区别"><a href="#创建对象的区别" class="headerlink" title="创建对象的区别"></a>创建对象的区别</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = Outter.Nested()<span class="comment">// 嵌套类，Outter后边没有括号</span></span><br><span class="line"><span class="keyword">var</span> demo = Outter().Inner();<span class="comment">// 内部类，Outter后边有括号</span></span><br></pre></td></tr></table></figure><p>也就是说，要想构造内部类的对象，必须先构造外部类的对象，而嵌套类则不需要.</p><h4 id="引用外部类的成员变量的方式不同"><a href="#引用外部类的成员变量的方式不同" class="headerlink" title="引用外部类的成员变量的方式不同"></a>引用外部类的成员变量的方式不同</h4><p>先来看嵌套类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;                  <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;             <span class="comment">// 嵌套类</span></span><br><span class="line">        <span class="keyword">var</span> ot: Outer = Outer()</span><br><span class="line">        println(ot.bar) <span class="comment">// 嵌套类可以引用外部类私有变量，但要先创建外部类的实例，不能直接引用</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下内部类:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">"成员属性"</span></span><br><span class="line">    <span class="comment">/**嵌套内部类**/</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">// 访问外部类成员</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">innerTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> o = <span class="keyword">this</span><span class="symbol">@Outer</span> <span class="comment">//获取外部类的成员变量</span></span><br><span class="line">            println(<span class="string">"内部类可以引用外部类的成员，例如："</span> + o.v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看来内部类可以直接通过 this@ 外部类名 的形式引用外部类的成员变量，不需要创建外部类对象；</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>使用对象表达式来创建匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">"成员属性"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setInterFace</span><span class="params">(test: <span class="type">TestInterFace</span>)</span></span> &#123;</span><br><span class="line">        test.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestInterFace</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> test = Test()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用对象表达式来创建接口对象，即匿名内部类的实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    test.setInterFace(<span class="keyword">object</span> : TestInterFace &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"对象表达式创建匿名内部类的实例"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 特别注意这里的 object : TestInterFace，这个 object 是 Kotlin 的关键字，要实现匿名内部类，就必须使用 object 关键字，不能随意替换其它单词.</p><h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><p>类的修饰符包括 classModifier 和<em>accessModifier</em></p><h3 id="classModifier-类属性修饰符，标示类本身特性"><a href="#classModifier-类属性修饰符，标示类本身特性" class="headerlink" title="classModifier: 类属性修饰符，标示类本身特性"></a>classModifier: 类属性修饰符，标示类本身特性</h3><ul><li>abstract    // 抽象类  </li><li>final       // 类不可继承，默认属性</li><li>enum        // 枚举类</li><li>open        // 类可继承，类默认是final的</li><li>annotation  // 注解类</li></ul><h3 id="accessModifier-访问权限修饰符"><a href="#accessModifier-访问权限修饰符" class="headerlink" title="accessModifier: 访问权限修饰符"></a>accessModifier: 访问权限修饰符</h3><ul><li>private    // 仅在同一个文件中可见</li><li>protected  // 同一个文件中或子类可见</li><li>public     // 所有调用的地方都可见</li><li>internal   // 同一个模块中可见</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在 Kotlin 中所有类都有一个共同的父类 Any，这对于没有父类声明的类是默认父类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> // 从 <span class="title">Any</span> 隐式继承</span></span><br></pre></td></tr></table></figure><p>注: Any 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode() 与 toString() 外没有任何成员</p><h2 id="继承父类"><a href="#继承父类" class="headerlink" title="继承父类"></a>继承父类</h2><p>要继承一个父类，我们把类型放到类头的冒号之后：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure><p>注:</p><ul><li>默认情况下，在 Kotlin 中所有的类都是 final. 类上的 open 标注与 Java 中 final 相反，它允许其他类从这个类继承.</li><li>如果子类有主构造函数, 它的父类则必须在父类的主构造函数里立即初始化.</li><li>如果子类没有主构造函数, 则子类的每个次构造函数必须使用 super 关键字初始化父类构造函数, 或者调用另一个构造函数. 不同的次构造函数可以调用父类的不同的构造函数.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx, attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在父类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。<br>如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nv</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>() : Base() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherDerived</span></span>() : Base() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性重写"><a href="#属性重写" class="headerlink" title="属性重写"></a>属性重写</h3><p>属性重写同方法重写一样, 需使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span> : <span class="type">Foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 可以用一个 var 属性覆盖一个 val 属性，但反之则不行.<br>因为一个 val 属性本质上声明了一个 getter 方法，而将其覆盖为 var 只是在子类中额外声明一个 setter 方法; 反过来, 父类 var 声明了 getter 和 setter 方法, 子类 val 不能有 setter 方法, 即无法重写父类的 setter 方法, 相当于缩小了父类相应属性的使用范围, 是不允许的.</p><p>可以在主构造函数中使用 override 关键字作为属性声明的一部分:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span>  <span class="comment">// 接口的成员变量默认是 open 的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span>) : Foo</span><br></pre></td></tr></table></figure><p>注: 子类继承父类时，默认不能有跟父类同名的变量，除非父类中该变量为 private，或者父类中该变量为 open 并且子类用 override 关键字重写</p><h3 id="子类初始化顺序"><a href="#子类初始化顺序" class="headerlink" title="子类初始化顺序"></a>子类初始化顺序</h3><p>在构建派生类的新势力的过程中, 第一步是完成其父类的初始化, 第二步才是完成子类的初始化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    init &#123; println(<span class="string">"Initializing Base"</span>) &#125;   <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> = </span><br><span class="line">    name.length.also &#123; println(<span class="string">"Initializing size in Base: <span class="variable">$it</span>"</span>) &#125;  <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(</span><br><span class="line">    name: String,</span><br><span class="line">    <span class="keyword">val</span> lastName: String</span><br><span class="line">) : Base(name.capitalize().also &#123; println(<span class="string">"Argument for Base: <span class="variable">$it</span>"</span>) &#125;) &#123;    <span class="comment">// 1.</span></span><br><span class="line"></span><br><span class="line">    init &#123; println(<span class="string">"Initializing Derived"</span>) &#125;    <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> =</span><br><span class="line">    (<span class="keyword">super</span>.size + lastName.length).also &#123; println(<span class="string">"Initializing size in Derived: <span class="variable">$it</span>"</span>) &#125;    <span class="comment">// 5.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子类调用父类函数及属性"><a href="#子类调用父类函数及属性" class="headerlink" title="子类调用父类函数及属性"></a>子类调用父类函数及属性</h2><p>子类可以使用 super 关键字调用其父类的函数与属性:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; println(<span class="string">"Foo.f()"</span>) &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> : <span class="type">Foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; </span><br><span class="line">        <span class="keyword">super</span>.f()</span><br><span class="line">        println(<span class="string">"Bar.f()"</span>) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() = <span class="keyword">super</span>.x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实现：super@Outer：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> : <span class="type">Foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; <span class="comment">/* …… */</span> &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="symbol">super@</span>Bar.f() <span class="comment">// 调用 Foo 实现的 f()</span></span><br><span class="line">            println(<span class="symbol">super@</span>Bar.x) <span class="comment">// 使用 Foo 实现的 x 的 getter</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h3><p>在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接父类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）.<br>为了表示采用从哪个父类继承的实现，我们使用由尖括号中父类名限定的 super，如 super<base>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123; print(<span class="string">"a"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125; <span class="comment">// 接口成员默认就是“open”的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123; print(<span class="string">"b"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>() : A(), B &#123;</span><br><span class="line">    <span class="comment">// 编译器要求覆盖 f()：</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.f() <span class="comment">// 调用 A.f()</span></span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.f() <span class="comment">// 调用 B.f()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时继承 A 与 B 没问题，并且 a() 与 b() 也没问题因为 C 只继承了每个函数的一个实现。 但是 f() 由 C 继承了两个实现，所以我们必须在 C 中覆盖 f() 并且提供我们自己的实现来消除歧义.</p>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> class </tag>
            
            <tag> extend </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第五课 -- 返回与跳转</title>
      <link href="/2018/08/26/Kotlin-%E7%AC%AC%E4%BA%94%E8%AF%BE-%E8%BF%94%E5%9B%9E%E4%B8%8E%E8%B7%B3%E8%BD%AC/"/>
      <url>/2018/08/26/Kotlin-%E7%AC%AC%E4%BA%94%E8%AF%BE-%E8%BF%94%E5%9B%9E%E4%B8%8E%E8%B7%B3%E8%BD%AC/</url>
      <content type="html"><![CDATA[<h1 id="返回与跳转-return-break-continue"><a href="#返回与跳转-return-break-continue" class="headerlink" title="返回与跳转: return break continue"></a>返回与跳转: return break continue</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = person.name ?: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这些表达式的类型是 Nothing 类型<br><a id="more"></a></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用标签限制 break 或者continue:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span> <span class="comment">// 非局部直接返回到 foo() 的调用者</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"this point is unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return:</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach <span class="symbol">lit@</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@lit</span> <span class="comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">" done with explicit label"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">" done with implicit label"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">3</span>) <span class="keyword">return</span>  <span class="comment">// 局部返回到匿名函数的调用者，即 forEach 循环</span></span><br><span class="line">        print(value)</span><br><span class="line">    &#125;)</span><br><span class="line">    print(<span class="string">" done with anonymous function"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    run <span class="symbol">loop@</span>&#123;</span><br><span class="line">        listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@loop</span> <span class="comment">// 从传入 run 的 lambda 表达式非局部返回</span></span><br><span class="line">            print(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">" done with nested loop"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当要返一个回值的时候，解析器优先选用标签限制的 return，即:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span><span class="symbol">@a</span> <span class="number">1</span> \\ 意为“从标签 <span class="meta">@a</span> 返回 <span class="number">1</span>”，而不是“返回一个标签标注的表达式 (<span class="meta">@a</span> <span class="number">1</span>)”</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> return </tag>
            
            <tag> break </tag>
            
            <tag> continue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第四课 -- 控制流语法</title>
      <link href="/2018/08/25/Kotlin-%E7%AC%AC%E5%9B%9B%E8%AF%BE-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/08/25/Kotlin-%E7%AC%AC%E5%9B%9B%E8%AF%BE-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="控制流-If-When-For-While"><a href="#控制流-If-When-For-While" class="headerlink" title="控制流: If, When, For, While"></a>控制流: If, When, For, While</h1><a id="more"></a><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><p>在 Kotlin 中，if是一个表达式，即它会返回一个值. 因此, 就不需要三元运算符了.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统用法</span></span><br><span class="line"><span class="keyword">var</span> max = a</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) max = b</span><br><span class="line"></span><br><span class="line"><span class="comment">// With else</span></span><br><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    max = a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为表达式</span></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>if的分支可以是代码块，最后的表达式作为该块的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">"Choose a"</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"Choose b"</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 如果你使用 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支.</p><h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><ul><li>when 取代了 switch 操作符</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注: 像 if 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值;<br>如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了［例如，对于 枚举（enum）类条目与密封（sealed）类子类型］.</p><ul><li>多个分支条件放一起</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检测一个值在（in）或者不在（!in）一个区间或者集合中</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    parseInt(s) -&gt; print(<span class="string">"s encodes x"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"s does not encode x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检测一个值是（is）或者不是（!is）一个特定类型的值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">    <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10.</span><span class="number">.20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以用来取代 if-else if链</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="For"><a href="#For" class="headerlink" title="For"></a>For</h2><ul><li>for 循环可以对任何提供迭代器（iterator）的对象进行遍历</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) print(item)</span><br></pre></td></tr></table></figure><ul><li>在数字区间上迭代</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过索引遍历一个数组或者一个 list</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    println(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用库函数 withIndex</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="While"><a href="#While" class="headerlink" title="While"></a>While</h2><p>正常使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> y = retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>) <span class="comment">// y 在此处可见</span></span><br></pre></td></tr></table></figure><h2 id="循环中的-Break-和-Continue"><a href="#循环中的-Break-和-Continue" class="headerlink" title="循环中的 Break 和 Continue"></a>循环中的 Break 和 Continue</h2><p>正常使用</p>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Control Flow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第三课 -- 包与导入</title>
      <link href="/2018/08/25/Kotlin-%E7%AC%AC%E4%B8%89%E8%AF%BE-%E5%8C%85%E4%B8%8E%E5%AF%BC%E5%85%A5/"/>
      <url>/2018/08/25/Kotlin-%E7%AC%AC%E4%B8%89%E8%AF%BE-%E5%8C%85%E4%B8%8E%E5%AF%BC%E5%85%A5/</url>
      <content type="html"><![CDATA[<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><a id="more"></a><p>源文件通常以包声明开头:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goo</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>源文件所有内容（无论是类还是函数）都包含在声明的包内。 所以上例中 baz() 的全名是 foo.bar.baz、Goo 的全名是 foo.bar.Goo.</p><p>如果没有指明包，该文件的内容属于无名字的默认包</p><h2 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h2><p>有多个包会默认导入到每个 Kotlin 文件中：</p><ul><li>kotlin.*</li><li>kotlin.annotation.*</li><li>kotlin.collections.*</li><li>kotlin.comparisons.* （自 1.1 起）</li><li>kotlin.io.*</li><li>kotlin.ranges.*</li><li>kotlin.sequences.*</li><li>kotlin.text.*</li></ul><p>根据目标平台还会导入额外的包：</p><p>JVM:</p><ul><li>ava.lang.*</li><li>kotlin.jvm.*</li></ul><p>JS:</p><ul><li>kotlin.js.*</li></ul><h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p>除了默认导入之外，每个文件可以包含它自己的导入指令。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo.Bar <span class="comment">// 现在 Bar 可以不用限定符访问</span></span><br><span class="line"><span class="keyword">import</span> foo.* <span class="comment">// “foo”中的一切都可访问</span></span><br><span class="line"><span class="keyword">import</span> bar.Bar <span class="keyword">as</span> bBar <span class="comment">// bBar 代表“bar.Bar”</span></span><br></pre></td></tr></table></figure><p>关键字 import 并不仅限于导入类；也可用它来导入其他声明：</p><ul><li>顶层函数及属性</li><li>在对象声明中声明的函数和属性</li><li>枚举常量</li></ul><p>注: 与 Java 不同, Kotlin 没有单独的 “import static” 语法</p>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> package </tag>
            
            <tag> import </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第二课 -- 基本数据类型</title>
      <link href="/2018/08/23/Kotlin-%E7%AC%AC%E4%BA%8C%E8%AF%BE-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/08/23/Kotlin-%E7%AC%AC%E4%BA%8C%E8%AF%BE-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>数字、字符、布尔值、数组与字符串</p><a id="more"></a><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><table><thead><tr><th style="text-align:center">Typt</th><th style="text-align:center">Bit Width</th></tr></thead><tbody><tr><td style="text-align:center">Double</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">Float</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">Long</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">Int</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">Short</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">Byte</td><td style="text-align:center">8</td></tr></tbody></table><p>注: Kotlin 处理数字与 Java 相近, 但不完全相同. 例如: Kotlin 没有对于数字的隐式拓宽转换, 而 Java 中有 int 隐式转换成 long</p><h3 id="字面常亮"><a href="#字面常亮" class="headerlink" title="字面常亮"></a>字面常亮</h3><ul><li>十进制: 123<br>  Long 类型用大写 L 标记: 123L</li><li>十六进制: 0x0F</li><li>二进制: 0b00001011</li></ul><p>注:</p><ol><li><p>不支持八进制</p></li><li><p>kotlin 同样支持浮点数表示法:</p><ul><li>默认 double: 123.5</li><li>Float 用 F 或 f 标记: 123.5f</li></ul></li><li><p>支持数字字面值的下划线:</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1</span>_000_000</span><br></pre></td></tr></table></figure></li></ol><h3 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h3><p>在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 Int?）或泛型。 后者情况下会把数字装箱<br>需注意, 数字装箱保留了相等性, 不保留同一性(同 Java)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">println(a == a) <span class="comment">// 输出“true”</span></span><br><span class="line">println(a === a) <span class="comment">// 输出“true”</span></span><br><span class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">println(boxedA == anotherBoxedA) <span class="comment">// 输出“true”</span></span><br><span class="line">println(boxedA === anotherBoxedA) <span class="comment">// ！！！输出“false”！！！</span></span><br></pre></td></tr></table></figure><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假想的代码，实际上并不能编译：</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="number">1</span> <span class="comment">// 一个装箱的 Int (java.lang.Integer)</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span>? = a <span class="comment">// 隐式转换产生一个装箱的 Long (java.lang.Long)</span></span><br><span class="line">print(b == a) <span class="comment">// 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long</span></span><br></pre></td></tr></table></figure><p>所以, 实际结果是这样:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>同时我们可以这样显式转换来拓宽数字:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// OK：显式拓宽</span></span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>每个数字类型支持如下转换:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">toByte(): <span class="built_in">Byte</span></span><br><span class="line">toShort(): <span class="built_in">Short</span></span><br><span class="line">toInt(): <span class="built_in">Int</span></span><br><span class="line">toLong(): <span class="built_in">Long</span></span><br><span class="line">toFloat(): <span class="built_in">Float</span></span><br><span class="line">toDouble(): <span class="built_in">Double</span></span><br><span class="line">toChar(): <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p>虽然没有隐式转换, 但是类型可以从上下文中推断出来:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="number">1</span>L + <span class="number">3</span> <span class="comment">// Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure><h3 id="智能转换"><a href="#智能转换" class="headerlink" title="智能转换"></a>智能转换</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPrefix</span><span class="params">(x: <span class="type">Any</span>)</span></span> = <span class="keyword">when</span>(x) &#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = (<span class="number">1</span> shl <span class="number">2</span>) and <span class="number">0x000FF000</span></span><br></pre></td></tr></table></figure><p>完整的位运算列表(只用于 Int 和 Long):</p><p>-. shl(bits) – 有符号左移 (Java 的 &lt;&lt;)<br>-. shr(bits) – 有符号右移 (Java 的 &gt;&gt;)<br>-. ushr(bits) – 无符号右移 (Java 的 &gt;&gt;&gt;)<br>-. and(bits) – 位与<br>-. or(bits) – 位或<br>-. xor(bits) – 位异或<br>-. inv() – 位非</p><h3 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h3><p>-. 相等性比较: a == b 与 a != b<br>-. 比较操作符：a &lt; b、 a &gt; b、 a &lt;= b、 a &gt;= b<br>-. 区间实例以及区间检测：a..b、 x in a..b、 x !in a..b</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>字符用 Char 类型表示。它们不能直接当作数字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// 错误：类型不兼容</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>布尔用 Boolean 类型表示，它有两个值：true 与 false</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组在 Kotlin 中使用 Array 类来表示，它定义了 get 与 set 函数（按照运算符重载约定这会转变为 []）以及 size 属性，以及一些其他有用的成员函数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建数组的三种方式:</p><ul><li><p>arrayOf(1, 2, 3) 创建了 array [1, 2, 3]</p></li><li><p>arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组</p></li><li><p>创建一个 Array<string> 初始化为 [“0”, “1”, “4”, “9”, “16”]</string></p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> asc = Array(<span class="number">5</span>, &#123; i -&gt; (i * i).toString() &#125;)</span><br></pre></td></tr></table></figure><p>注:<br>Kotlin 不让我们把 Array<string> 赋值给 Array<any>，以防止可能的运行时失败（但是你可以使用 Array<out any="">）</out></any></string></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串用 String 类型表示。字符串是不可变的。 字符串的元素——字符可以使用索引运算符访问: s[i]。 可以用 for 循环迭代字符串:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">"abcd"</span></span><br><span class="line">    <span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">        println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用 + 操作符连接字符串。这也适用于连接字符串与其他类型的值， 只要表达式中的第一个元素是字符串</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="number">2</span>+ <span class="string">"abc"</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h3><h4 id="转移字符串"><a href="#转移字符串" class="headerlink" title="转移字符串"></a>转移字符串</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"Hello, world!\n"</span></span><br></pre></td></tr></table></figure><h4 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">    for (c in "foo")</span></span><br><span class="line"><span class="string">        print(c)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>注: 可以通过 trimMargin() 函数去除前导空格</p><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>模板表达式以美元符（$）开头，由一个简单的名字构成:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">println(<span class="string">"i = <span class="variable">$i</span>"</span>) <span class="comment">// 输出“i = 10”</span></span><br></pre></td></tr></table></figure><p>或者用花括号括起来的任意表达式:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"abc"</span></span><br><span class="line">println(<span class="string">"<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span>) <span class="comment">// 输出“abc.length is 3”</span></span><br></pre></td></tr></table></figure><p>如果你需要在原始字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"<span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99"</span>) <span class="comment">// 输出“$9.99"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Data Type </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 第一课</title>
      <link href="/2018/08/22/Kotlin-%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
      <url>/2018/08/22/Kotlin-%E7%AC%AC%E4%B8%80%E8%AF%BE/</url>
      <content type="html"><![CDATA[<p>Kotlin是Jetbrains公司起初用于内部开发的而发起的一个开源项目，这个Jetbrains公司也许你没听过，但是IntelliJ IDEA你一定听过，没错你所用的Android Studio的老妈就是这个公司的产品。在 Google I/O 2017 大会上, 谷歌宣布 Kotlin 成为 Android 开发的官方编程语言.<br>Kotlin 不仅仅可以用于 Android 应用开发, 代码简洁且表现力强, 与 Java 完全兼容. 同时, Kotlin 还可以用来开发前端 React 应用.<br>作为一名 Android 开发, 也需要跟上自己的脚步, 学习 Kotlin 是很有必要的. 学习着, 随时准备着用在项目里.</p><a id="more"></a><h2 id="Kotlin-概述"><a href="#Kotlin-概述" class="headerlink" title="Kotlin 概述"></a>Kotlin 概述</h2><h3 id="Kotlin-用于-Android"><a href="#Kotlin-用于-Android" class="headerlink" title="Kotlin 用于 Android"></a>Kotlin 用于 Android</h3><ul><li><p><strong>兼容性</strong>: Kotlin 与 JDK 6 完全兼容, 保障了 Kotlin 应用程序可以在较旧的 Android 设备上运行而无任何问题。Kotlin 工具在 Android Studio 中会完全支持，并且兼容 Android 构建系统.</p></li><li><p><strong>性能</strong>: 由于非常相似的字节码结构，Kotlin 应用程序的运行速度与 Java 类似。 随着 Kotlin 对内联函数的支持，使用 lambda 表达式的代码通常比用 Java 写的代码运行得更快。</p></li><li><p><strong>互操作性</strong>: Kotlin 可与 Java 进行 100％ 的互操作，允许在 Kotlin 应用程序中使用所有现有的 Android 库 。这包括注解处理，所以数据绑定与 Dagger 也是一样。</p></li><li><p><strong>占用</strong>: Kotlin 具有非常紧凑的运行时库，可以通过使用 ProGuard 进一步减少。 在实际应用程序中，Kotlin 运行时只增加几百个方法以及 .apk 文件不到 100K 大小。</p></li><li><p><strong>编译时长</strong>: Kotlin 支持高效的增量编译，所以对于清理构建会有额外的开销，增量构建通常与 Java 一样快或者更快。</p></li><li><p><strong>学习曲线</strong>: 对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换器有助于迈出第一步。</p></li></ul><h3 id="Kotlin-用于-JavaScript"><a href="#Kotlin-用于-JavaScript" class="headerlink" title="Kotlin 用于 JavaScript"></a>Kotlin 用于 JavaScript</h3><h3 id="Kotlin-用于-服务器端"><a href="#Kotlin-用于-服务器端" class="headerlink" title="Kotlin 用于 服务器端"></a>Kotlin 用于 服务器端</h3><h3 id="Kotlin-Native"><a href="#Kotlin-Native" class="headerlink" title="Kotlin/Native"></a>Kotlin/Native</h3><h2 id="Kotlin-特性"><a href="#Kotlin-特性" class="headerlink" title="Kotlin 特性"></a>Kotlin 特性</h2><ul><li><strong>简洁</strong>: 大大地减少代码量.</li></ul><p>例如:<br>Java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private String name;</span><br><span class="line">  public void setId(long id) &#123;</span><br><span class="line">    this. id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setName(String name) &#123;</span><br><span class="line">    this. name=name;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getId() &#123;</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用一行代码创建一个包含 getters、 setters、 equals()、 hashCode()、 toString() 以及 copy() 的 POJO:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Customer(val id: String, val name: String)</span><br></pre></td></tr></table></figure></p><ul><li><strong>安全</strong>: 避免空指针异常等整个类的错误.</li></ul><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val name: String? = null    // 可控类型</span><br><span class="line">println(name.length())      // 编译错误</span><br></pre></td></tr></table></figure></p><ul><li><strong>互操作性</strong>: 充分利用 JVM, Android 和 浏览器的现有库.</li></ul><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flowable</span><br><span class="line">    .fromCallable &#123;</span><br><span class="line">        Thread.sleep(1000) //  模仿高开销的计算</span><br><span class="line">        &quot;Done&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.single())</span><br><span class="line">    .subscribe(::println, Throwable::printStackTrace)</span><br></pre></td></tr></table></figure></p><ul><li><strong>工具友好</strong>: 可用任何 Java IDE 或者使用命令行构建.</li></ul>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git教程</title>
      <link href="/2018/08/21/Git%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/21/Git%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>工欲善其器, 必先利其器.<br>今天给项目组的小伙伴们分享了 git 的使用, 所以就顺便再分享给大家.</p><a id="more"></a><h2 id="Git-的诞生"><a href="#Git-的诞生" class="headerlink" title="Git 的诞生"></a>Git 的诞生</h2><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。<br>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？<br>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！<br>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。<br>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。<br>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：<br>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。<br>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><h2 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么"></a>Git 是什么</h2><p><strong>分布式版本控制系统</strong></p><h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><p>记录一个或若干个内容变化, 以便将来查阅特定版本修订情况的系统</p><h3 id="集中式与分布式对比"><a href="#集中式与分布式对比" class="headerlink" title="集中式与分布式对比"></a>集中式与分布式对比</h3><p><img src="/images/centralization.png" alt="centralization"><br><img src="/images/distributed.png" alt="distributed"></p><h2 id="Git-的安装"><a href="#Git-的安装" class="headerlink" title="Git 的安装"></a>Git 的安装</h2><ul><li>Windows: git bash</li><li>Linux: apt-get install git</li><li>ac: 通过homebrew安装Git</li></ul><p>配置:</p><ul><li>$ git config –global user.name “Your Name”</li><li>$ git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“<br>注: 可以针对不同的 repo 配置不同的用户名及邮箱</li></ul><h2 id="Git-版本库的初始化"><a href="#Git-版本库的初始化" class="headerlink" title="Git 版本库的初始化"></a>Git 版本库的初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>Or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xx@xxxx</span><br></pre></td></tr></table></figure></p><p><img src="/images/version_repository.png" alt="version_repository"></p><h2 id="Git-的常见操作"><a href="#Git-的常见操作" class="headerlink" title="Git 的常见操作"></a>Git 的常见操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">要查看哪些文件处于什么状态</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git add .</span><br><span class="line">暂存已修改文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br><span class="line">假如你修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输 入了 git add . 暂存了它们两个，此时取消一个文件&lt;file&gt;的暂存用git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">查看本地分支</span><br><span class="line"></span><br><span class="line">git branch -a</span><br><span class="line">查看本地+远程分支</span><br><span class="line"></span><br><span class="line">git branch 分支名</span><br><span class="line">创建本地分支</span><br><span class="line"></span><br><span class="line">git branch -D 分支名</span><br><span class="line">删除本地分支</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br><span class="line">切换分支</span><br><span class="line"></span><br><span class="line">git checkout -b 分支名</span><br><span class="line">基于当前分支创建一个分支, 并切换到当前分支</span><br><span class="line">(git branch 分支名 + git checkout 分支名)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br><span class="line">查看工作区文件更改差异</span><br><span class="line"></span><br><span class="line">git diff --staged</span><br><span class="line">查看暂存区文件差异</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &lt;commit message&gt;</span><br><span class="line">提交更新</span><br><span class="line"></span><br><span class="line">git commit --amend</span><br><span class="line">修改上次提交</span><br><span class="line"></span><br><span class="line">建议:</span><br><span class="line">先用 git status 看下，是不是修改都已暂存起来了</span><br><span class="line">commit 格式: 模块: 内容</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br><span class="line">如果你并不想保留对文件&lt;file&gt;的修改，你可以将它还原成上次提交时的样子，即撤销对&lt;file&gt;的更改（不可恢复）。</span><br><span class="line"></span><br><span class="line">git reset HEAD^</span><br><span class="line">撤销上次提交</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">查看提交历史</span><br><span class="line"></span><br><span class="line">git log -p -2</span><br><span class="line">一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">推送到远程仓库</span><br><span class="line"></span><br><span class="line">git pull </span><br><span class="line"> 例如:git pull origin develop:branch </span><br><span class="line">取回远程 develop 分支，与本地branch 分支合并。省略:branch 默认和当前分支合并</span><br><span class="line"> 实质上，git pull = git fetch + git merge</span><br><span class="line"></span><br><span class="line">git fetch</span><br><span class="line">下载远端的版本库</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br><span class="line">与branch分支合并，git merge origin/&lt;branch&gt; 与远程分支合并。  </span><br><span class="line"></span><br><span class="line">git rebase &lt;branch&gt;</span><br><span class="line">rebase 意思为变基。git rebase origin/&lt;branch&gt;与远程分支合并</span><br></pre></td></tr></table></figure><h3 id="git-rebase-和-git-merge-的区别"><a href="#git-rebase-和-git-merge-的区别" class="headerlink" title="git rebase 和 git merge 的区别"></a>git rebase 和 git merge 的区别</h3><p><img src="/images/merge_rebase.png" alt="merge_rebase"></p><h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br><span class="line">在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用&quot;git-add&quot;命令去更新这些内容的索引(index), 然后，你无需执行 git-commit</span><br><span class="line">这样git会继续应用余下的补丁</span><br><span class="line"></span><br><span class="line"> git rebase --abort</span><br><span class="line">在任何时候，你可以用--abort参数来终止rebase的行动，并且&quot;mywork&quot; 分支会回到rebase开始前的状态。</span><br></pre></td></tr></table></figure><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用merge出现冲突时，会出现 CONFLICT ，后面提示冲突的文件，解决所有冲突后，使用git add . 将已解决的冲突添加到暂存并提交。</span><br><span class="line">如有需要，再使用git commit --amend 把暂存区的改动提交到上一次提交中。</span><br></pre></td></tr></table></figure><h3 id="commit-的合并"><a href="#commit-的合并" class="headerlink" title="commit 的合并"></a>commit 的合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>使用此命令来合并多个提交，HEAD~2 中的2表示将最近的两次提交合并成一个提交。<br>使用后会出现类似如下界面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br></pre></td></tr></table></figure></p><p>将第二个 pick 改为 squash 或 s 后保存退出，即将两次提交合成一个。<br>或者使用 git reset <sha> 回退到某一次提交后，重新 git commit -m <commit message=""> 可以实现相同的效果。</commit></sha></p><h3 id="二分法快速定位问题代码"><a href="#二分法快速定位问题代码" class="headerlink" title="二分法快速定位问题代码"></a>二分法快速定位问题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good a67f7</span><br><span class="line">git bisect reset</span><br></pre></td></tr></table></figure><h2 id="总结-GIT-的通用流程"><a href="#总结-GIT-的通用流程" class="headerlink" title="总结: GIT 的通用流程"></a>总结: GIT 的通用流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone</span><br><span class="line">git  checkout -b &lt;分支名&gt;</span><br><span class="line">git add .</span><br><span class="line">git commit -m “”</span><br><span class="line">git push origin &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line">git fetch</span><br><span class="line">git rebase origin/dev</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br><span class="line">git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> git教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/19/hello-world/"/>
      <url>/2018/07/19/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
